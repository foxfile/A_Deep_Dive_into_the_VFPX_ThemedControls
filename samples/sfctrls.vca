SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCS0T59BS
[CLASS] checkbox
[BASECLASS] checkbox
[OBJNAME] sfcheckbox
[START PROPERTIES]
	<memberdata name="about" type="method" display="About" favorites="True"/>
	<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
	<memberdata name="builder" type="property" display="Builder"/>
	<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
	<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
	<memberdata name="lsaveanchor" display="lSaveAnchor"/><memberdata name="lsaveanchor_assign" display="lSaveAnchor_Assign"/></VFPData>
	<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
	<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
	<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
	<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
	<memberdata name="oexception" type="property" display="oException"/>
	<memberdata name="ohook" type="property" display="oHook"/>
	<memberdata name="omenu" type="property" display="oMenu"/>
	<memberdata name="onformchange" type="method" display="OnFormChange"/>
	<memberdata name="release" type="method" display="Release"/>
	<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
	<memberdata name="showmenu" type="method" display="ShowMenu"/>
	<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource" favorites="True"/>
	<memberdata name="validation" type="method" display="Validation" favorites="True"/>
Alignment = 0
AutoSize = .T.
BackStyle = 0
Caption = "Check1"
FontName = "Tahoma"
Name = "sfcheckbox"
Value = .F.
_memberdata =     1607<VFPData>
builder = 
lbindtoformanychange = .F.
lnotifyonformchange = .F.
lsaveanchor = .F.
lskipvalidonformclose = .T.
lupdatecontrolsource = .T.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
* Update the control source in case something binding to our AnyChange event
* looks at it.

if This.lUpdateControlSource
	This.UpdateControlSource()
endif This.lUpdateControlSource

* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE KeyPress
* Prevent Ctrl-0 from inserting a null value.

lparameters tnKeyCode, ;
	tnShiftAltCtrl
if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
	nodefault
endif tnKeyCode = asc('0') ...

ENDPROC
PROCEDURE ProgrammaticChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE Valid
*==============================================================================
* Method:			Valid
* Status:			Public
* Purpose:			Validate the Value
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	08/20/2002
* Parameters:		none
* Returns:			.T. if the validation succeeded or we're not doing the
*						validation
* Environment in:	none
* Environment out:	none
*==============================================================================

* If the Valid method is fired because the user clicked on a button with the
* Cancel property set to .T. or if the button has an lCancel property (which
* is part of the SFCommandButton base class) and it's .T., or if we're closing
* the form, don't bother doing the rest of the validation.

local loObject
loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
	(This.lSkipValidOnFormClose and ;
	type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
	return .T.
endif (type('loObject.lCancel') = 'L' ...

* If the user tries to leave this control but a field validation rule failed,
* we'll prevent them from doing so.

if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
	Thisform.lFieldRuleFailed = .F.
	return 0
endif type('Thisform.lFieldRuleFailed') = 'L' ...

* Do the custom validation (this allows the developer to put custom validation
* code into the Validation method rather than having to use code like the
* following in the Valid method:
*
* dodefault()
* custom code here
* nodefault

return This.Validation()

ENDPROC
PROCEDURE When
* Prevent the checkbox from receiving focus in a read-only column.

return (upper(This.Parent.BaseClass) <> 'COLUMN' or not This.Parent.ReadOnly)

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFCheckBox
* Based On:						CheckBox
* Purpose:						Base class for all CheckBox objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:				12/02/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	AutoSize:					.T.
*	BackStyle:					0 (Transparent)
*	FontName:					Tahoma
*	Value:						.F. since checkboxes usually are used for
*								logical values
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						ensure the object is wide enough to display the
*								caption by resetting AutoSize. Bind
*								InteractiveChangeto the form's AnyChange method
*								and bind OnFormChange to the form's lChanged
*								property if necessary. Change FontName to
*								Segoe UI in Vista
*	InteractiveChange:			raises the AnyChange event
*	KeyPress:					ignore Ctrl-0
*	ProgrammaticChange:			raises the AnyChange event
*	RightClick:					call This.ShowMenu
*	Valid:						prevent validation code from executing if the
*								user is cancelling, retain focus if a field
*								rule failed, and call the custom Validation
*								method
*	When:						prevent the control from receiving focus in a
*								read-only column
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
*								the form is closed
*	lUpdateControlSource:		.T. if UpdateControlSource should be called
*								from InteractiveChange
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the ControlSource with the new value
*	Validation:					abstract method for custom validation code
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE anychange
* Abstract method.

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001 Stonefield Systems Group Inc.
* Last revision:	01/24/2001
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
PROCEDURE validation
* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatecontrolsource Updates the ControlSource with the new value
*validation Abstract method for custom validation code
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lskipvalidonformclose .T. if we can skip validating this control when the form is closed
lupdatecontrolsource .T. if UpdateControlSource should be called from InteractiveChange
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Base class for CheckBox objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcheckbox
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RF810ZEZK
[CLASS] sfcheckbox
[CLASSLOC] sfctrls.vcx
[BASECLASS] checkbox
[OBJNAME] sfcheckboxgraphical
[START PROPERTIES]
Alignment = 0
AutoSize = .F.
Caption = ""
Height = 23
Name = "sfcheckboxgraphical"
Style = 1
Width = 23
[END PROPERTIES]
[START METHODS]
PROCEDURE about
*==============================================================================
* Class:						SFCheckBoxGraphical
* Based On:						SFCheckBox
* Purpose:						Graphical CheckBox
* Author:						Doug Hennig
* Copyright:					(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:				03/12/2010
* Include file:					none
*
* Changes in "Based On" class properties:
*	AutoSize:					.F.
*	Caption:					None
*	Height:						23
*	Style:						1 (Graphical)
*	Width:						23
*
* Changes in "Based On" class methods:
*	None
*
* Custom public properties added:
*	None
*
* Custom protected properties added:
*	None
*
* Custom public methods added:
*	None
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Graphical CheckBox[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcheckboxgraphical
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0VB0RDEMT
[CLASS] collection
[BASECLASS] collection
[OBJNAME] sfcollection
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="additem" type="method" display="AddItem"/>
<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
<memberdata name="cleanup" type="method" display="Cleanup"/>
<memberdata name="clear" type="method" display="Clear"/>
<memberdata name="fillarrayrow" type="method" display="FillArrayRow" favorites="True"/>
<memberdata name="fillcollection" type="method" display="FillCollection"/>
<memberdata name="getarray" type="method" display="GetArray"/>
<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
<memberdata name="lfilloninit" type="property" display="lFillOnInit" favorites="True"/>
<memberdata name="lrelease" type="property" display="lRelease"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
<memberdata name="removeitem" type="method" display="RemoveItem"/>
<memberdata name="savecollection" type="method" display="SaveCollection"/>
<memberdata name="saveitem" type="method" display="SaveItem" favorites="True"/>
Height = 23
Name = "sfcollection"
Width = 23
_memberdata =     1300<VFPData>
cerrormessage = 
lerroroccurred = .F.
lrelease = .F.
oexception = .NULL.
[END PROPERTIES]
[START PROTECTED]
calledfromthisclass
fillarrayrow
lrelease
[END PROTECTED]
[START METHODS]
PROCEDURE Add
lparameters tuItem, ;
	tcKey, ;
	tuBefore, ;
	tuAfter
local lcKey
do case
	case pcount() = 1
		dodefault(tuItem)
	case vartype(tcKey) = 'C'
		lcKey = upper(alltrim(tcKey))
		do case
			case This.GetKey(lcKey) > 0
			case pcount() = 2
				dodefault(tuItem, lcKey)
			case pcount() = 3
				dodefault(tuItem, lcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, lcKey, tuBefore, tuAfter)
		endcase
	case pcount() = 3
		dodefault(tuItem, tcKey, tuBefore)
	case pcount() = 4
		dodefault(tuItem, tcKey, tuBefore, tuAfter)
endcase
nodefault

ENDPROC
PROCEDURE Destroy
* Cleanup as the object is destroyed.

This.Cleanup()

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE GetKey
lparameters tuIndex
local lcIndex, ;
	luReturn
if vartype(tuIndex) = 'C'
	lcIndex  = upper(alltrim(tuIndex))
	luReturn = dodefault(lcIndex)
else
	luReturn = dodefault(tuIndex)
endif vartype(tuIndex) = 'C'
nodefault
return luReturn

ENDPROC
PROCEDURE Init
* Fill the collection if we're supposed to.

with This
	if .lFillOnInit
		.FillCollection()
	endif .lFillOnInit
endwith

ENDPROC
PROCEDURE Item
lparameters tuIndex
local luReturn, ;
	lcIndex
luReturn = .NULL.
if vartype(tuIndex) = 'C'
	lcIndex = upper(alltrim(tuIndex))
	if This.GetKey(lcIndex) > 0
		luReturn = dodefault(lcIndex)
	endif This.GetKey(lcIndex) > 0
else
	try
		luReturn = dodefault(tuIndex)
	catch
	endtry
endif vartype(tuIndex) = 'C'
nodefault
return luReturn

ENDPROC
PROCEDURE Remove
lparameters tuIndex
local lcIndex, ;
	luReturn
if vartype(tuIndex) = 'C'
	lcIndex = upper(alltrim(tuIndex))
	if This.GetKey(lcIndex) > 0
		dodefault(lcIndex)
	endif This.GetKey(lcIndex) > 0
else
	dodefault(tuIndex)
endif vartype(tuIndex) = 'C'
nodefault

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFCollection
* Based On:						Collection
* Purpose:						Base class for all Collection objects
* Author:						Doug Hennig
* Copyright:					(c) 2003-2008 Stonefield Systems Group Inc.
* Last revision:				10/06/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	None
*
* Changes in "Based On" class methods:
*	Add:						store upper-cased key so case-insensitive and
*									ignore duplicate keys
*	Destroy:					cleanup as the object is destroyed
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	GetKey:						handle case-insensitivity
*	Init:						calls FillCollection if lFillOnInit is .T.
*	Item:						return .NULL. if the item isn't found and
*								handle case-insensitivity
*	Remove:						handle case-insensitivity
*
* Custom public properties added:
*	cErrorMessage:				the message of an error
*	lErrorOccurred:				.T. if an error occurred
*	lFillOnInit:				.T. if we're supposed to fill the collection
*								when it's instantiated
*	oException:					a reference to an Exception object
*
* Custom protected properties added:
*	lRelease:					.T. as the object is being released
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AddItem:					adds an item (backward compatibility)
*	Clear:						clears the collection
*	GetArray:					fills the passed array with information about
*								objects in the collection
*	FillCollection:				loads the collection from persistent storage
*	Release:					releases the object
*	ReleaseMembers:				abstract method to nuke member references
*	RemoveItem:					removes an item (backward compatibility)
*	SaveCollection:				saves the collection to persistent storage
*	SaveItem:					saves the specified item to persistent storage
*
* Custom protected methods added:
*	CalledFromThisClass:		returns .T. if a method was called from this
*								class
*	Cleanup:					cleans up member references when the object is
*								released or destroyed
*	FillArrayRow:				fills the specified row in the passed array
*								with information about the current item
*==============================================================================

ENDPROC
PROCEDURE additem
lparameters tuItem, ;
	tcKey, ;
	tuBefore, ;
	tuAfter
local luReturn
do case
	case pcount() = 1
		luReturn = This.Add(tuItem)
	case pcount() = 2
		luReturn = This.Add(tuItem, tcKey)
	case pcount() = 3
		luReturn = This.Add(tuItem, tcKey, tuBefore)
	case pcount() = 4
		luReturn = This.Add(tuItem, tcKey, tuBefore, tuAfter)
endcase
return luReturn

ENDPROC
PROCEDURE calledfromthisclass
*==============================================================================
* Method:			CalledFromThisClass
* Status:			Protected
* Purpose:			Determines if the method that called this method was called
*						from a method of this class or an ancestor
* Author:			Doug Hennig
* Copyright:		(c) 1998-2005 Stonefield Systems Group Inc.
* Last Revision:	01/29/2005
* Parameters:		none
* Returns:			.T. if the method that called this method was called from a
*						method of this class or an ancestor
* Environment in:	none
* Environment out:	none
* Notes:			The reason we want to know if the method that called this
*						method was called from a method of this class or not is
*						to permit "read-only" properties to be changed only by
*						methods of this class. This would typically be called
*						from an Assign method, such as:
*
*					lparameters tuNewValue
*					if This.CalledFromThisClass()
*						This.<property> = tuNewValue
*					else
*						error 1743, '<property>'   && property is read-only
*					endif This.CalledFromThisClass()
*==============================================================================

local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	loParent, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn, ;
	lcThisName

* Get the name of the program that called us, and get the object name from it.
* Set loParent to our parent if there is one.

lnLevel   = program(-1)
lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI

* If we didn't come from ourselves or an ancestor and we have a parent, our
* name may not match our class, so check the containership hierarchy.

if not llReturn and not isnull(loParent)
	lcThisName = This.Name
	do while vartype(loParent) = 'O'
		lcThisName = loParent.Name + '.' + lcThisName
		loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
			.NULL.)
	enddo while vartype(loParent) = 'O'
	llReturn = upper(lcObject) == upper(lcThisName)
endif not llReturn ...
return llReturn

ENDPROC
PROCEDURE cleanup
*==============================================================================
* Method:			Cleanup
* Status:			Protected
* Purpose:			Nuke member objects
* Author:			Doug Hennig
* Copyright:		(c) 1998-2005 Stonefield Systems Group Inc.
* Last Revision:	01/29/2005
* Parameters:		none
* Returns:			.T. if everything succeeded
* Environment in:	This.lRelease is .T. if we're already in the process of
*						releasing
* Environment out:	This.lRelease is .T.
*					This.ReleaseMembers() was called
* Notes:			This methods avoids use of "with This" to prevent potential
*						problems with dangling object references
*==============================================================================

if This.lRelease
	return .F.
endif This.lRelease
This.lRelease = .T.
This.ReleaseMembers()

ENDPROC
PROCEDURE clear
This.Remove(-1)

ENDPROC
PROCEDURE fillarrayrow
lparameters taArray, ;
	tnItem, ;
	toItem
taArray[tnItem] = toItem

ENDPROC
PROCEDURE fillcollection
* Abstract method

ENDPROC
PROCEDURE getarray
lparameters taArray
local lnItem, ;
	loItem
if This.Count > 0
	dimension taArray[This.Count]
else
	dimension taArray[1]
endif This.Count > 0
lnItem = 0
for each loItem in This foxobject
	lnItem = lnItem + 1
	This.FillArrayRow(@taArray, lnItem, loItem)
next loItem
return This.Count

ENDPROC
PROCEDURE release
* Release the object. Note the avoidance of "with This" in this code to prevent
* potential problems with dangling object references.

if This.lRelease
	nodefault
	return .F.
endif This.lRelease
This.Cleanup()
release This

ENDPROC
PROCEDURE releasemembers
* Abstract method

ENDPROC
PROCEDURE removeitem
lparameters tuIndex
return This.Remove(tuIndex)

ENDPROC
PROCEDURE savecollection
local loItem
for each loItem in This foxobject
	This.SaveItem(loItem)
next loItem

ENDPROC
PROCEDURE saveitem
lparameters toItem

* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*additem Adds an item (backward compatibility)
*calledfromthisclass Determines if the method that called this method was called from a method of this class or an ancestor
*cleanup Cleans up member references when the object is released or destroyed
*clear Clears the collection
*fillarrayrow Fills the specified row in the passed array with information about the current item
*fillcollection Loads the collection from persistent storage
*getarray Fills the passed array with information about objects in the collection
*release Releases the object
*releasemembers Abstract method to nuke member references
*removeitem Removes an item (backward compatibility)
*savecollection Saves the collection to persistent storage
*saveitem Saves the specified item to persistent storage
_memberdata XML Metadata for customizable properties
cerrormessage The text of an error message
lerroroccurred .T. if an error occurred
lfilloninit .T. if we're supposed to fill the collection when it's instantiated
lrelease .T. as the object is being released
oexception A reference to an Exception object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcollection

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _15P0X25YF
[CLASS] sfcollection
[CLASSLOC] sfctrls.vcx
[BASECLASS] collection
[OBJNAME] sfcollectiononeclass
[START PROPERTIES]
</VFPData>
<memberdata name="citemclass" type="property" display="cItemClass" favorites="True"/>
<memberdata name="citemlibrary" type="property" display="cItemLibrary" favorites="True"/>
<memberdata name="isvalidname" type="method" display="IsValidName"/>
Name = "sfcollectiononeclass"
_memberdata =      265<VFPData>
citemclass = 
citemlibrary = 
[END PROPERTIES]
[START PROTECTED]
isvalidname
[END PROTECTED]
[START METHODS]
PROCEDURE Add
lparameters tuItem, ;
	tcKey, ;
	tuBefore, ;
	tuAfter
local loItem, ;
	lcName
with This

* If an object was specified for the first parameter, use it and get the name
* from the second parameter.

	if vartype(tuItem) = 'O'
		loItem = tuItem
		lcName = tcKey

* No object was specified, so create one and get the name from the first
* parameter.

	else
		loItem = newobject(.cItemClass, .cItemLibrary)
		lcName = tuItem
	endif vartype(tuItem) = 'O'

* Set the cName property if there is one.

	if not empty(lcName) and pemstatus(loItem, 'cName', 5)
		loItem.cName = lcName
	endif not empty(lcName) ...

* Set the Name property is there is one and we have a valid name (assuming we
* don't have any Empty object, in which case we don't care if the name is
* valid).

	do case
		case not pemstatus(loItem, 'Name', 5)
		case not empty(lcName) and (not pemstatus(loItem, 'Class', 5) or ;
			.IsValidName(lcName))
			loItem.Name = lcName
		otherwise
			loItem.Name = sys(2015)
	endcase

* Add the item to the collection and return a reference to it.

	if empty(lcName)
		dodefault(loItem)
	else
		dodefault(loItem, lcName)
		loItem = .Item(lcName)
	endif empty(lcName)
	nodefault
endwith
return loItem

ENDPROC
PROCEDURE Error
lparameters tnError, ;
	tcMethod, ;
	tnLine
local lcReturn

* Ignore "key must be specified" or "not an array" errors.

if tnError = cnERR_KEY_MUST_BE_SPECIFIED or tnError = cnERR_NOT_AN_ARRAY

* Use the normal error handling mechanism for all other types of errors. Note
* that we add a period to the method name passed. This tells our parent class
* to return the error resolution string back to us, which is required for RETRY
* to work.

else
	lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
	lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
	do case

* It wasn't our error, so pass it back to the calling method.

		case '.' $ tcMethod
			return lcReturn

* Handle the error choices.

		case lcReturn = ccMSG_RETRY
			retry
		case lcReturn = ccMSG_DEBUG
			debug
			if wexist('Visual FoxPro Debugger')
				keyboard '{SHIFT+F7}' plain
			endif wexist('Visual FoxPro Debugger')
			suspend
		case lcReturn = ccMSG_CANCEL
			cancel
		otherwise
			return
	endcase
endif tnError = cnERR_KEY_MUST_BE_SPECIFIED ...

ENDPROC
PROCEDURE fillarrayrow
lparameters taArray, ;
	tnItem, ;
	toItem
taArray[tnItem] = toItem.Name

ENDPROC
PROCEDURE isvalidname
*==============================================================================
* Method:			IsValidName
* Status:			Protected
* Purpose:			Returns .T. if the name of a new item is valid
* Author:			Doug Hennig
* Copyright:		(c) 1998-2004 Stonefield Systems Group Inc.
* Last revision:	02/02/2004
* Parameters:		tcName - the name to assign to the item
* Returns:			.T. if the name is valid
* Environment in:	none
* Environment out:	none
*==============================================================================

lparameters tcName
local llReturn, ;
	lnI, ;
	lcChar
llReturn = .T.
for lnI = 1 to len(tcName)
	lcChar = substr(tcName, lnI, 1)
	if not isalpha(lcChar) and not (lnI > 1 and isdigit(lcChar))
		llReturn = .F.
		exit
	endif not isalpha(lcChar) ...
next lnI
return llReturn

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*isvalidname Returns .T. if the name of a new item is valid
citemclass The class to create items from
citemlibrary The library containing the class specified in cItemClass
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcollectiononeclass

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1LU0KQB36
[CLASS] sfcollectiononeclass
[CLASSLOC] sfctrls.vcx
[BASECLASS] collection
[OBJNAME] sfcollectiontable
[START PROPERTIES]

</VFPData>
<memberdata name="addrecord" type="method" display="AddRecord"/>
<memberdata name="calias" type="property" display="cAlias"/>
<memberdata name="createentityobject" type="method" display="CreateEntityObject"/>
<memberdata name="ctable" type="property" display="cTable"/>
<memberdata name="getentityname" type="method" display="GetEntityName"/>
<memberdata name="opentable" type="method" display="OpenTable"/>
<memberdata name="removerecord" type="method" display="RemoveRecord"/>
Name = "sfcollectiontable"
_memberdata =      500<VFPData>
calias = 
ctable = 
[END PROPERTIES]
[START PROTECTED]
addrecord
calias
createentityobject
getentityname
opentable
removerecord
[END PROTECTED]
[START METHODS]
PROCEDURE Add
lparameters tuItem, ;
	tcKey
local loEntity
do case

* If we were passed a name, add a record to the table and use the default
* behavior to add it to the collection. Note that we re-read loEntity from the
* collection in case we were specified a duplicate name and it isn't added to
* the collection.

	case vartype(tuItem) = 'C'
		loEntity = This.AddRecord(tuItem)
		loEntity = dodefault(loEntity, tuItem)

* We were passed an object, so add it to the collection. As above, we re-read
* the object from the collection in case it's a duplicate.

	case vartype(tuItem) = 'O'
		loEntity = tuItem
		loEntity = dodefault(loEntity, tcKey)

* Invalid parameters.

	otherwise
		loEntity = .NULL.
		throw 'Function argument value, type, or count is invalid.'
endcase
nodefault
return loEntity

ENDPROC
PROCEDURE Remove
* If the object exists in the collection, remove it from the collection and
* remove the matching record from the table.

lparameters tuIndex
local loEntity
loEntity = This.Item(tuIndex)
if vartype(loEntity) = 'O'
	dodefault(tuIndex)
	This.RemoveRecord(loEntity)
endif vartype(loEntity) = 'O'
nodefault

ENDPROC
PROCEDURE addrecord
lparameters tcName

* Abstract method

ENDPROC
PROCEDURE createentityobject
* Abstract method

ENDPROC
PROCEDURE fillcollection
* Fill the collection from the table.

local lnSelect, ;
	loEntity, ;
	lcName, ;
	llReturn
if This.OpenTable()
	lnSelect = select()
	select (This.cAlias)
	scan
		loEntity = This.CreateEntityObject()
		lcName   = This.GetEntityName(loEntity)
		This.Add(loEntity, lcName)
	endscan
	select (lnSelect)
	llReturn = .T.
endif This.OpenTable()
return llReturn

ENDPROC
PROCEDURE getentityname
lparameters toEntity
return toEntity.Name

ENDPROC
PROCEDURE opentable
* Open the table and store the alias in cAlias. Set AutoIncError to .F. in case
* we use GATHER NAME in some method and don't want an error if any ID fields
* are used.

local loException as Exception
if empty(This.cAlias)
	This.cAlias = '__' + juststem(This.cTable)
endif empty(This.cAlias)
if not used(This.cAlias)
	try
		use (This.cTable) again shared alias (This.cAlias) in 0
		cursorsetprop('AutoIncError', .F., This.cAlias)
	catch to loException
		This.oException    = loException
		This.cErrorMessage = loException.Message
	endtry
endif not used(This.cAlias)
return used(This.cAlias)

ENDPROC
PROCEDURE releasemembers
* Save the collection and close the table.

This.SaveCollection()
if not empty(This.cAlias)
	use in select(This.cAlias)
endif not empty(This.cAlias)
dodefault()

ENDPROC
PROCEDURE removerecord
lparameters toEntity

* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addrecord Adds a record to the table
*createentityobject Creates an entity object
*getentityname Returns the name of the specified entity
*opentable Opens the table
*removerecord Removes the record for the specified entity from the table
calias The alias assigned to the table
ctable The name and path to the table
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcollectiontable

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCS0T68ZJ
[CLASS] combobox
[BASECLASS] combobox
[OBJNAME] sfcombobox
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="aitems" type="property" display="aItems"/>
<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="ccollectionobjectproperty" type="property" display="cCollectionObjectProperty" favorites="True"/>
<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lrequeryoninit" type="property" display="lRequeryOnInit" favorites="True"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="orowsourcecollection" type="property" display="oRowSourceCollection" favorites="True"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
<memberdata name="validation" type="method" display="Validation" favorites="True"/>
BoundTo = .T.
FontName = "Tahoma"
ItemTips = .T.
Name = "sfcombobox"
RowSource = "This.aItems"
RowSourceType = 5
SelectOnEntry = .T.
Style = 2
_memberdata =     1947<VFPData>
builder = 
ccollectionobjectproperty = 
lbindtoformanychange = .F.
lnotifyonformchange = .F.
lrequeryoninit = .T.
lsaveanchor = .F.
lskipvalidonformclose = .T.
lupdatecontrolsource = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
orowsourcecollection = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.
This.oRowSourceCollection = .NULL.

ENDPROC
PROCEDURE DropDown
* Set DisplayCount to an appropriate value based on how much room there is
* below the form.

local lnHeight
lnHeight = iif(Thisform.ShowWindow = 2 or ;
	(pemstatus(Thisform, 'Desktop', 5) and Thisform.Desktop), sysmetric(2), ;
	_vfp.Height)
This.DisplayCount = max(ceiling((lnHeight - Thisform.Top - ;
	objtoclient(This, 1))/This.Height), 7)

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* Call Requery() if we're supposed to; otherwise, initialize aItems to a blank
* string.

	if .lRequeryOnInit
		.Requery()
	else
		.aItems = ''
	endif .lRequeryOnInit

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
* Update the control source in case something binding to our AnyChange event
* looks at it.

if This.lUpdateControlSource
	This.UpdateControlSource()
endif This.lUpdateControlSource

* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE KeyPress
* Prevent Ctrl-0 from inserting a null value.

lparameters tnKeyCode, ;
	tnShiftAltCtrl
if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
	nodefault
endif tnKeyCode = asc('0') ...

* Prevent backspace from leaving the control.

if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
   nodefault
endif tnKeyCode = 127 ...

ENDPROC
PROCEDURE ProgrammaticChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE Requery
* If RowSource is 0-None or 1-Value but an array specified in RowSource
* contains values or oRowSourceCollection contains a collection, use AddItem
* (in the case of 0-None) or set RowSource to a comma-delimited list of values
* (in the case of 1-Value) from the array or the collection. This allows
* disabled lines using a prompt of "\-".

lparameters tlNoAction
local lcRowSource, ;
	llArray, ;
	llColumn, ;
	lnRows, ;
	lnI, ;
	lcItem, ;
	luItem
with This
	lcRowSource = .RowSource
	if empty(lcRowSource)
		lcRowSource = 'This.aItems'
	endif empty(lcRowSource)
	if not empty(lcRowSource)
		try
			llArray = type(lcRowSource, 1) = 'A'
		catch
		endtry
	endif not empty(lcRowSource)
	do case

* If we're not supposed to do anything or we're not using 0-None or 1-Value, do
* nothing.

		case tlNoAction or not inlist(.RowSourceType, 0, 1)

* Handle items in an array referenced in RowSource. Note that we can't combine
* the CASE and IF statements or we'll get an error.

		case not empty(lcRowSource) and llArray
			if type(lcRowSource + '[1]') = 'C' and ;
				(not empty(&lcRowSource.[1]) or alen(&lcRowSource., 1) > 1)
				if .RowSourceType <> 0
					.RowSource = ''
				endif .RowSourceType <> 0
				.Clear()
				llColumn = alen(&lcRowSource, 2) > 0
				lnRows   = alen(&lcRowSource, 1)
				for lnI = 1 to lnRows
					lcItem = iif(llColumn, &lcRowSource[lnI, 1], ;
						&lcRowSource[lnI])
					if .RowSourceType = 0
						.AddItem(lcItem)
					else
						.RowSource = .RowSource + iif(lnI = 1, '', ',') + ;
							lcItem
					endif .RowSourceType = 0
				next lnI
			endif type(lcRowSource + '[1]') = 'C' ...

* Handle items in oRowSourceCollection.

		case vartype(.oRowSourceCollection) = 'O' and ;
			upper(.oRowSourceCollection.BaseClass) = 'COLLECTION' and ;
			.oRowSourceCollection.Count > 0
			if .RowSourceType <> 0
				.RowSource = ''
			endif .RowSourceType <> 0
			.Clear()
			for each luItem in .oRowSourceCollection foxobject
				if vartype(luItem) = 'O'
					lcItem = evaluate('luItem.' + .cCollectionObjectProperty)
				else
					lcItem = luItem
				endif vartype(luItem) = 'O'
				if .RowSourceType = 0
					.AddItem(lcItem)
				else
					.RowSource = .RowSource + ;
						iif(empty(.RowSource), '', ',') + lcItem
				endif .RowSourceType = 0
			next luItem
	endcase
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE Valid
*==============================================================================
* Method:			Valid
* Status:			Public
* Purpose:			Validate the Value
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	08/20/2002
* Parameters:		none
* Returns:			.T. if the validation succeeded or we're not doing the
*						validation
* Environment in:	none
* Environment out:	none
*==============================================================================

* If the Valid method is fired because the user clicked on a button with the
* Cancel property set to .T. or if the button has an lCancel property (which
* is part of the SFCommandButton base class) and it's .T., or if we're closing
* the form, don't bother doing the rest of the validation.

local loObject
loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
	(This.lSkipValidOnFormClose and ;
	type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
	return .T.
endif (type('loObject.lCancel') = 'L' ...

* If the user tries to leave this control but a field validation rule failed,
* we'll prevent them from doing so.

if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
	Thisform.lFieldRuleFailed = .F.
	return 0
endif type('Thisform.lFieldRuleFailed') = 'L' ...

* Do the custom validation (this allows the developer to put custom validation
* code into the Validation method rather than having to use code like the
* following in the Valid method:
*
* dodefault()
* custom code here
* nodefault

return This.Validation()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFComboBox
* Based On:						ComboBox
* Purpose:						Base class for all ComboBox objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:				10/09/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	BoundTo:					.T.
*	FontName:					Tahoma
*	ItemTips:					.T.
*	RowSource:					This.aItems (see below)
*	RowSourceType:				5 (Array)
*	SelectOnEntry:				.T.
*	Style:						2 (Dropdown List) because this is what we
*								usually use
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	DropDown:					set DisplayCount to an appropriate value based
*								on how much room there is below the form
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						initialize This.aItems to blanks and call
*								This.Requery if This.lRequeryOnInit is .T. Bind
*								InteractiveChange to the form's AnyChange
*								method and bind OnFormChange to the form's
*								lChanged property if necessary. Change FontName
*								to Segoe UI in Vista
*	InteractiveChange:			calls UpdateControlSource and raises the
*								AnyChange event
*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
*								control
*	ProgrammaticChange:			raises the AnyChange event
*	Requery:					handle RowSourceType = 0-None or 1-Value when
*								RowSource references an array containing the
*								values or oRowSourceCollection references a
*								collection with the values
*	RightClick:					call This.ShowMenu
*	Valid:						prevent validation code from executing if the
*								user is cancelling, retain focus if a field
*								rule failed, and call the custom Validation
*								method
*
* Custom public properties added:
*	aItems[1]:					an array that can hold the values used for the
*								ComboBox when RowSourceType is 5
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	cCollectionObjectProperty:	the property of objects in the collection
*								specified by oRowSourceCollection used to fill
*								the combobox
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lRequeryOnInit:				.T. to call Requery from Init
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
*								the form is closed
*	lUpdateControlSource:		.T. if UpdateControlSource should be called
*								from InteractiveChange
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*	oRowSourceCollection:		a reference to a Collection object that
*								provides the row source elements
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the control source
*	Validation:					abstract method for custom validation code
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE anychange
* Abstract method

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	08/24/2005
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	oLocalizer may contain a reference to a localization object
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject
local lcCut, ;
	lcCopy, ;
	lcPaste, ;
	lcClear, ;
	lcSelect
if This.Style = 0
	if type('oLocalizer.Name') = 'C'
		lcCut    = oLocalizer.GetLocalizedString('MENU_CUT')
		lcCopy   = oLocalizer.GetLocalizedString('MENU_COPY')
		lcPaste  = oLocalizer.GetLocalizedString('MENU_PASTE')
		lcClear  = oLocalizer.GetLocalizedString('MENU_CLEAR')
		lcSelect = oLocalizer.GetLocalizedString('MENU_SELECT_ALL')
	else
		lcCut    = 'Cu\<t'
		lcCopy   = '\<Copy'
		lcPaste  = '\<Paste'
		lcClear  = 'Cle\<ar'
		lcSelect = 'Se\<lect All'
	endif type('oLocalizer.Name') = 'C'
	with toMenu
		.AddMenuBar(lcCut,    "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
			'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
			'CutXPSmall.bmp', '_med_cut')
		.AddMenuBar(lcCopy,   "sys(1500, '_MED_COPY',  '_MEDIT')", , , , , , ;
			'CopyXPSmall.bmp', '_med_copy')
		.AddMenuBar(lcPaste,  "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
			'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
			'PasteXPSmall.bmp', '_med_paste')
		.AddMenuBar(lcClear,  "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
			'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
			'_med_clear', '_med_clear')
		.AddMenuSeparator()
		.AddMenuBar(lcSelect, "sys(1500, '_MED_SLCTA', '_MEDIT')", , , , , , ;
			'_med_slcta', '_med_slcta')
	endwith
endif This.Style = 0

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
* Last revision:	02/27/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
PROCEDURE validation
* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatecontrolsource Updates the control source
*validation An abstract method for custom validation code
^aitems[1,0] An array that can hold the values used for the ComboBox when RowSourceType is 5
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
ccollectionobjectproperty The property of objects in the collection specified by oRowSourceCollection used to fill the combobox
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lrequeryoninit .T. to call Requery from Init
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lskipvalidonformclose .T. if we can skip validating this control when the form is closed
lupdatecontrolsource .T. if UpdateControlSource should be called from InteractiveChange
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
orowsourcecollection A reference to a Collection object that provides the row source elements
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Base class for ComboBox objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcombobox
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCT0LM35E
[CLASS] commandbutton
[BASECLASS] commandbutton
[OBJNAME] sfcommandbutton
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="lcancel" type="property" display="lCancel" favorites="True"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
Caption = "Command1"
FontName = "Tahoma"
Height = 27
Name = "sfcommandbutton"
Width = 84
_memberdata =     1113<VFPData>
builder = 
lcancel = .F.
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFCommandButton
* Based On:						CommandButton
* Purpose:						Base class for all CommandButton objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2007 Stonefield Systems Group Inc.
* Last revision:				04/27/2007
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	FontName:					Tahoma
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T. Change FontName to
*								Segoe UI in Vista
*	RightClick:					call This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lCancel:					.T. if this button is used as a "cancel" button
*								(this allows the Valid of a control to not
*								bother doing validation if the user clicked a
*								"cancel" button)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lcancel .T. if this is used as a "cancel" button (this allows the Valid of a control to not bother doing validation if the user clicked a "cancel" button)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Base class for CommandButton objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcommandbutton
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RD10QJ6FB
[CLASS] container
[BASECLASS] container
[OBJNAME] sfcontainer
[START PROPERTIES]
	<memberdata name="about" type="method" display="About"/>
	<memberdata name="builder" type="property" display="Builder"/>
	<memberdata name="buildercode" display="BuilderCode"/></VFPData>
	<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
	<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
	<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
	<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
	<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
	<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
	<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
	<memberdata name="oexception" type="property" display="oException"/>
	<memberdata name="ohook" type="property" display="oHook"/>
	<memberdata name="omenu" type="property" display="oMenu"/>
	<memberdata name="onformchange" type="method" display="OnFormChange"/>
	<memberdata name="release" type="method" display="Release"/>
	<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
	<memberdata name="showmenu" type="method" display="ShowMenu"/>
Anchor = 15
BackStyle = 0
BorderWidth = 0
Name = "sfcontainer"
_memberdata =     1280<VFPData>
builder = 
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
calledfromthisclass
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
local loException as Exception, ;
	loParent
with This

* Set lUseFormShortcutMenu for all contained objects to the same as ours.

	try
		.SetAll('lUseFormShortcutMenu', .lUseFormShortcutMenu)
	catch to loException
	endtry

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFContainer
* Based On:						Container
* Purpose:						Base class for all Container objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:				02/02/2010
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	Anchor:						15 (resize height and width)
*	BackStyle:					0 (Transparent)
*	BorderWidth:				0
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						set lUseFormShortcutMenu for all contained
*								objects to the same as ours and bind
*								OnFormChange to the form's lChanged property if
*								necessary
*	RightClick:					call This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	BuilderCode:				code for a self-contained builder
*	Enabled_Assign:				sets the Enabled property of the object and all
*								member objects to the specified value so all
*								objects appear to be enabled or disabled
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	CalledFromThisClass:		returns .T. if a method was called from this
*								class
*==============================================================================

ENDPROC
PROCEDURE buildercode
* This method can hold self-contained builder code. To use it, fill in this
* method with code that accepts a parameter (a reference to this object) and
* uses that parameter to reference to the object (you can't use "This" because
* the code will actually be copied to a script PRG and executed there). Then
* simply double-click the Builder property in PEM Editor to invoke the builder.

lparameters toThis

ENDPROC
PROCEDURE calledfromthisclass
*==============================================================================
* Method:			CalledFromThisClass
* Status:			Protected
* Purpose:			Determines if the method that called this method was called
*						from a method of this class or an ancestor
* Author:			Doug Hennig
* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
* Last Revision:	09/27/2001
* Parameters:		none
* Returns:			.T. if the method that called this method was called from a
*						method of this class or an ancestor
* Environment in:	none
* Environment out:	none
* Notes:			The reason we want to know if the method that called this
*						method was called from a method of this class or not is
*						to permit "read-only" properties to be changed only by
*						methods of this class. This would typically be called
*						from an Assign method, such as:
*
*					lparameters tuNewValue
*					if This.CalledFromThisClass()
*						This.<property> = tuNewValue
*					else
*						error 1743, '<property>'   && property is read-only
*					endif This.CalledFromThisClass()
*==============================================================================

local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	loParent, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn, ;
	lcThisName

* Get the name of the program that called us, and get the object name from it.
* Set loParent to our parent if there is one.

lnLevel   = program(-1)
lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI

* If we didn't come from ourselves or an ancestor and we have a parent, our
* name may not match our class, so check the containership hierarchy.

if not llReturn and not isnull(loParent)
	lcThisName = This.Name
	do while vartype(loParent) = 'O'
		lcThisName = loParent.Name + '.' + lcThisName
		loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
			.NULL.)
	enddo while vartype(loParent) = 'O'
	llReturn = upper(lcObject) == upper(lcThisName)
endif not llReturn ...
return llReturn

ENDPROC
PROCEDURE enabled_assign
* Enable or disable member objects.

lparameters tlEnabled
This.SetAll('Enabled', tlEnabled)
This.Enabled = tlEnabled

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*buildercode Code for a self-contained builder; see notes in the method for instructions
*calledfromthisclass Returns .T. if a method was called from this class
*enabled_assign 
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class) or double-click to call code in BuilderCode *** .BuilderCode(loObject)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Base class for Container objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcontainer

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R1G0LLW08
[CLASS] custom
[BASECLASS] custom
[OBJNAME] sfcustom
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
<memberdata name="cleanup" type="method" display="Cleanup"/>
<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lrelease" type="property" display="lRelease"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
Name = "sfcustom"
Width = 17
_memberdata =     1259<VFPData>
builder = 
cerrormessage = 
lerroroccurred = .F.
lnotifyonformchange = .F.
lrelease = .F.
luseformshortcutmenu = .F.
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
calledfromthisclass
cleanup
lrelease
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Cleanup as the object is destroyed.

This.Cleanup()

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2006 Stonefield Systems Group Inc.
* Last revision:	04/26/2006
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	llCOMMode, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
llCOMMode = inlist(_VFP.StartMode, 2, 3, 5)
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* If we're not running in a COM server, display a generic dialog box with an
* option to display the debugger (this should only occur in a test
* environment).

	case not llCOMMode
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Use COMRETURNERROR() if we're running in a COM server.

	case llCOMMode
		comreturnerror('', 'Error ' + lnError + ' occurred in line ' + ;
			transform(lnLine) + ' of ' + lcMethod)

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
* If we're supposed to bind to the lChanged property of the form, do so.

if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
	pemstatus(Thisform, 'lChanged', 5)
	bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
endif This.lNotifyOnFormChange ...

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFCustom
* Based On:						Custom
* Purpose:						Base class for all Custom objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2006 Stonefield Systems Group Inc.
* Last revision:				04/26/2006
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	Width:						17 so the object is small when dropped on a
*								form
*
* Changes in "Based On" class methods:
*	Destroy:					cleanup as the object is destroyed
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T.
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	cErrorMessage:				the message of an error
*	lErrorOccurred:				.T. if an error occurred
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	lRelease:					.T. as the object is being released
*
* Custom public methods added:
*	About:						provides documentation for the class
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ReleaseMembers:				abstract method to nuke member references
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	CalledFromThisClass:		returns .T. if a method was called from this
*								class
*	Cleanup:					cleans up member references when the object is
*								released or destroyed
*==============================================================================

ENDPROC
PROCEDURE calledfromthisclass
*==============================================================================
* Method:			CalledFromThisClass
* Status:			Protected
* Purpose:			Determines if the method that called this method was called
*						from a method of this class or an ancestor
* Author:			Doug Hennig
* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
* Last Revision:	09/27/2001
* Parameters:		none
* Returns:			.T. if the method that called this method was called from a
*						method of this class or an ancestor
* Environment in:	none
* Environment out:	none
* Notes:			The reason we want to know if the method that called this
*						method was called from a method of this class or not is
*						to permit "read-only" properties to be changed only by
*						methods of this class. This would typically be called
*						from an Assign method, such as:
*
*					lparameters tuNewValue
*					if This.CalledFromThisClass()
*						This.<property> = tuNewValue
*					else
*						error 1743, '<property>'   && property is read-only
*					endif This.CalledFromThisClass()
*==============================================================================

local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	loParent, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn, ;
	lcThisName

* Get the name of the program that called us, and get the object name from it.
* Set loParent to our parent if there is one.

lnLevel   = program(-1)
lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI

* If we didn't come from ourselves or an ancestor and we have a parent, our
* name may not match our class, so check the containership hierarchy.

if not llReturn and not isnull(loParent)
	lcThisName = This.Name
	do while vartype(loParent) = 'O'
		lcThisName = loParent.Name + '.' + lcThisName
		loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
			.NULL.)
	enddo while vartype(loParent) = 'O'
	llReturn = upper(lcObject) == upper(lcThisName)
endif not llReturn ...
return llReturn

ENDPROC
PROCEDURE cleanup
*==============================================================================
* Method:			Cleanup
* Status:			Protected
* Purpose:			Nuke member objects
* Author:			Doug Hennig
* Copyright:		(c) 1998 Stonefield Systems Group Inc.
* Last Revision:	03/24/99
* Parameters:		none
* Returns:			.T. if everything succeeded
* Environment in:	This.lRelease is .T. if we're already in the process of
*						releasing
* Environment out:	This.lRelease is .T.
*					This.oHook is .NULL.
*					This.ReleaseMembers() was called
* Notes:			This methods avoids use of "with This" to prevent potential
*						problems with dangling object references
*==============================================================================

if This.lRelease
	return .F.
endif This.lRelease
This.lRelease = .T.
This.ReleaseMembers()
This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE release
* Release the object. Note the avoidance of "with This" in this code to prevent
* potential problems with dangling object references.

if This.lRelease
	nodefault
	return .F.
endif This.lRelease
This.Cleanup()
release This

ENDPROC
PROCEDURE releasemembers
* Abstract method

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	03/26/99
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*calledfromthisclass Returns .T. if a method was called from this class
*cleanup Cleans up member references when the object is released or destroyed
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*releasemembers Abstract method to nuke member references
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
cerrormessage The message of an error
lerroroccurred .T. if an error occurred
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lrelease .T. as the object is being released
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Base class for Custom objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfcustom

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCS0T6MAM
[CLASS] editbox
[BASECLASS] editbox
[OBJNAME] sfeditbox
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="czoomclass" type="property" display="cZoomClass" favorites="True"/>
<memberdata name="czoomformcaption" type="property" display="cZoomFormCaption" favorites="True"/>
<memberdata name="czoomlibrary" type="property" display="cZoomLibrary" favorites="True"/>
<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
<memberdata name="lcanchangefont" type="property" display="lCanChangeFont" favorites="True"/>
<memberdata name="lcanfind" type="property" display="lCanFind" favorites="True"/>
<memberdata name="lcanzoom" type="property" display="lCanZoom" favorites="True"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="selectfont" type="method" display="SelectFont"/>
<memberdata name="setzoomformproperties" type="method" display="SetZoomFormProperties" favorites="True"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
<memberdata name="validation" type="method" display="Validation" favorites="True"/>
<memberdata name="zoom" type="method" display="Zoom"/>
Anchor = 15
FontName = "Tahoma"
IntegralHeight = .T.
Name = "sfeditbox"
SelectOnEntry = .T.
_memberdata =     2224<VFPData>
builder = 
czoomclass = SFEditBoxZoomForm
czoomformcaption = 
czoomlibrary = SFCtrls.vcx
lbindtoformanychange = .F.
lcanchangefont = .F.
lcanfind = .F.
lcanzoom = .F.
lnotifyonformchange = .F.
lsaveanchor = .F.
lskipvalidonformclose = .T.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE KeyPress
* Prevent Ctrl-0 from inserting a null value.

lparameters tnKeyCode, ;
	tnShiftAltCtrl
if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
	nodefault
endif tnKeyCode = asc('0') ...

* Prevent backspace from leaving the control.

if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
   nodefault
endif tnKeyCode = 127 ...

ENDPROC
PROCEDURE ProgrammaticChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE Valid
*==============================================================================
* Method:			Valid
* Status:			Public
* Purpose:			Validate the Value
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	08/20/2002
* Parameters:		none
* Returns:			.T. if the validation succeeded or we're not doing the
*						validation
* Environment in:	none
* Environment out:	none
*==============================================================================

* If the Valid method is fired because the user clicked on a button with the
* Cancel property set to .T. or if the button has an lCancel property (which
* is part of the SFCommandButton base class) and it's .T., or if we're closing
* the form, don't bother doing the rest of the validation.

local loObject
loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
	(This.lSkipValidOnFormClose and ;
	type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
	return .T.
endif (type('loObject.lCancel') = 'L' ...

* If the user tries to leave this control but a field validation rule failed,
* we'll prevent them from doing so.

if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
	Thisform.lFieldRuleFailed = .F.
	return 0
endif type('Thisform.lFieldRuleFailed') = 'L' ...

* Do the custom validation (this allows the developer to put custom validation
* code into the Validation method rather than having to use code like the
* following in the Valid method:
*
* dodefault()
* custom code here
* nodefault

return This.Validation()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFEditBox
* Based On:						EditBox
* Purpose:						Base class for all EditBox objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:				10/09/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	Anchor:						15 (resize height and width)
*	FontName:					Tahoma
*	IntegralHeight:				.T.
*	SelectOnEntry:				.T.
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind InteractiveChange to the form's AnyChange
*								method and bind OnFormChange to the form's
*								lChanged property if necessary. Change FontName
*								to Segoe UI in Vista
*	InteractiveChange:			raises the AnyChange event
*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
*								control
*	ProgrammaticChange:			raises the AnyChange event
*	RightClick:					call This.ShowMenu
*	Valid:						prevent validation code from executing if the
*								user is cancelling, retain focus if a field
*								rule failed, and call the custom Validation
*								method
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	cZoomClass:					the class to use for the "zoom" form
*	cZoomFormCaption:			the caption for the "zoom" form
*	cZoomLibrary:				the library containing the class specified in
*								cZoomClass
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lCanChangeFont:				.T. if the user can change the font
*	lCanFind:					.T. if the user can bring up the Find dialog
*	lCanZoom:					.T. if the user can zoom this control
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
*								the form is closed
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	SelectFont:					selects the font for the control
*	SetZoomFormProperties:		sets properties of the zoom form before it's
*								displayed
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the ControlSource with the new value
*	Validation:					abstract method for custom validation code
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE anychange
* Abstract method

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE selectfont
local lcStyle, ;
	lcFont, ;
	lnPos1, ;
	lnPos2
with This
	lcStyle = iif(.FontBold, 'B', '') + iif(.FontItalic, 'I', '')
	lcFont  = getfont(.FontName, .FontSize, lcStyle)
	if not empty(lcFont)
		lnPos1      = at(',', lcFont, 1)
		lnPos2      = at(',', lcFont, 2)
		.FontName   = left(lcFont, lnPos1 - 1)
		.FontSize   = val(substr(lcFont, lnPos1 + 1, lnPos2 - lnPos1 - 1))
		lcFont      = substr(lcFont, lnPos2 + 1)
		.FontBold   = 'B' $ lcFont
		.FontItalic = 'I' $ lcFont
	endif not empty(lcFont)
endwith

ENDPROC
PROCEDURE setzoomformproperties
* Abstract method.

lparameters toForm

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:	02/19/2008
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	oLocalizer may contain a reference to a localization object
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject
local lcUndo, ;
	lcRedo, ;
	lcCut, ;
	lcCopy, ;
	lcPaste, ;
	lcClear, ;
	lcSelect, ;
	lcFont, ;
	lcZoom, ;
	lcFind
if type('oLocalizer.Name') = 'C'
	lcUndo   = oLocalizer.GetLocalizedString('MENU_UNDO')
	lcRedo   = oLocalizer.GetLocalizedString('MENU_REDO')
	lcCut    = oLocalizer.GetLocalizedString('MENU_CUT')
	lcCopy   = oLocalizer.GetLocalizedString('MENU_COPY')
	lcPaste  = oLocalizer.GetLocalizedString('MENU_PASTE')
	lcClear  = oLocalizer.GetLocalizedString('MENU_CLEAR')
	lcSelect = oLocalizer.GetLocalizedString('MENU_SELECT_ALL')
	lcFont   = oLocalizer.GetLocalizedString('MENU_FONT')
	lcZoom   = oLocalizer.GetLocalizedString('MENU_ZOOM')
	lcFind   = oLocalizer.GetLocalizedString('MENU_FIND')
else
	lcUndo   = '\<Undo'
	lcRedo   = 'Re\<do'
	lcCut    = 'Cu\<t'
	lcCopy   = '\<Copy'
	lcPaste  = '\<Paste'
	lcClear  = 'Cle\<ar'
	lcSelect = 'Se\<lect All'
	lcFont   = 'F\<ont...'
	lcZoom   = '\<Zoom...'
	lcFind   = '\<Find...'
endif type('oLocalizer.Name') = 'C'
with toMenu
	.AddMenuBar(lcUndo,   "sys(1500, '_MED_UNDO',  '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'UndoXPSmall.bmp', '_med_undo')
	.AddMenuBar(lcRedo,   "sys(1500, '_MED_REDO',  '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'RedoXPSmall.bmp', '_med_redo')
	.AddMenuSeparator()
	.AddMenuBar(lcCut,    "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'CutXPSmall.bmp', '_med_cut')
	.AddMenuBar(lcCopy,   "sys(1500, '_MED_COPY',  '_MEDIT')", , , , , , ;
		'CopyXPSmall.bmp', '_med_copy')
	.AddMenuBar(lcPaste,  "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'PasteXPSmall.bmp', '_med_paste')
	.AddMenuBar(lcClear,  "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'_med_clear', '_med_clear')
	.AddMenuSeparator()
	.AddMenuBar(lcSelect, "sys(1500, '_MED_SLCTA', '_MEDIT')", , , , , , ;
		'_med_slcta', '_med_slcta')
	if This.lCanChangeFont or This.lCanFind or This.lCanZoom
		.AddMenuSeparator()
	endif This.lCanChangeFont ...
	if This.lCanChangeFont
		.AddMenuBar(lcFont, tcObject + '.SelectFont()')
	endif This.lCanChangeFont
	if This.lCanFind
		.AddMenuBar(lcFind, "sys(1500, '_MED_FIND', '_MEDIT')", , , , , , ;
			'FindXPSmall.bmp', '_med_find')
	endif This.lCanFind
	if This.lCanZoom
		.AddMenuBar(lcZoom, tcObject + '.Zoom()', , , , , , 'Zoom.bmp')
	endif This.lCanZoom
endwith

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
* Last revision:	02/27/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
PROCEDURE validation
* Abstract method

ENDPROC
PROCEDURE zoom
local lcName, ;
	loForm
private pcValue
lcName = This.Name
loForm = newobject(This.cZoomClass, This.cZoomLibrary)
with loForm
	pcValue  = This.Value
	.Caption = This.cZoomFormCaption
	.Icon    = Thisform.Icon
	with .edtZoom
		.ControlSource = 'pcValue'
		.FontName      = This.FontName
		.FontSize      = This.FontSize
		.FontBold      = This.FontBold
		.FontItalic    = This.FontItalic
	endwith
	This.SetZoomFormProperties(loForm)
	.Show()
endwith
This.Value = pcValue

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*selectfont Selects the font for the control
*setzoomformproperties Sets properties of the zoom form before it's displayed
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatecontrolsource Updates the ControlSource with the new value
*validation An abstract method for custom validation code
*zoom Displays a form with a zoomed edit box in it
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
czoomclass The class to use for the "zoom" form
czoomformcaption The caption for the "zoom" form
czoomlibrary The library containing the class specified in cZoomClass
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lcanchangefont .T. if the user can change the font
lcanfind .T. if the user can bring up the Find dialog
lcanzoom .T. if the user can zoom this control
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lskipvalidonformclose .T. if we can skip validating this control when the form is closed
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Base class for EditBox objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfeditbox
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0N30ZCC2O
[CLASS] sfmodaldialog
[CLASSLOC] sfctrls.vcx
[BASECLASS] form
[OBJNAME] sfeditboxzoomform
[START PROPERTIES]
Caption = ""
Desktop = .T.
DoCreate = .T.
KeyPreview = .T.
MaxButton = .T.
Name = "sfeditboxzoomform"
cregistrykey = 
nborderstyle = 3
oregistry = .NULL.
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
* If we have a Registry key, instantiate an SFRegistry object.

local lcLibrary
with This
	lcLibrary = 'SFRegistry.vcx'
	if not empty(.cRegistryKey) and file(lcLibrary)
		.oRegistry = newobject('SFRegistry', lcLibrary)
	endif not empty(.cRegistryKey) ...
endwith
dodefault()

ENDPROC
PROCEDURE KeyPress
lparameters tnKeyCode, ;
	tnShiftAltCtrl
if tnKeyCode = 27 or tnKeyCode = 23
	if tnKeyCode = 23
		store This.edtZoom.Value to (This.edtZoom.ControlSource)
	endif tnKeyCode = 23
	This.Hide()
else
	dodefault(tnKeyCode, tnShiftAltCtrl)
endif tnKeyCode = 27 ...

ENDPROC
PROCEDURE Resize
with This
	.edtZoom.Height = .Height - .edtZoom.Top
	.edtZoom.Width  = .Width
endwith

ENDPROC
PROCEDURE Show
* Restore our size, position, and font from the Registry.

lparameters tnStyle
with This
	if not empty(.cRegistryKey)
		.Height = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomHeight', ;
			transform(.Height)))
		.Width  = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomWidth', ;
			transform(.Width)))
		.Top    = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomTop', ;
			transform(.Top)))
		.Left   = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomLeft', ;
			transform(.Left)))
		.edtZoom.FontName   = .oRegistry.GetKey(.cRegistryKey, 'ZoomFont', ;
			.edtZoom.FontName)
		.edtZoom.FontSize   = val(.oRegistry.GetKey(.cRegistryKey, ;
			'ZoomFontSize', transform(.edtZoom.FontSize)))
		.edtZoom.FontBold   = .oRegistry.GetKey(.cRegistryKey, 'ZoomBold', ;
			transform(.edtZoom.FontBold, 'Y')) = 'Y'
		.edtZoom.FontItalic = .oRegistry.GetKey(.cRegistryKey, 'ZoomItalic', ;
			transform(.edtZoom.FontItalic, 'Y')) = 'Y'
	endif not empty(.cRegistryKey)

* Resize the form even if we didn't restore the values since the calling
* EditBox may have resized us.

	.Resize()
endwith
dodefault(tnStyle)

ENDPROC
PROCEDURE releasemembers
* Save our settings in the Registry.

with This
	if not empty(.cRegistryKey)
		.oRegistry.SetKey(.cRegistryKey, 'ZoomHeight', transform(.Height))
		.oRegistry.SetKey(.cRegistryKey, 'ZoomWidth',  transform(.Width))
		.oRegistry.SetKey(.cRegistryKey, 'ZoomTop',    transform(.Top))
		.oRegistry.SetKey(.cRegistryKey, 'ZoomLeft',   transform(.Left))
		.oRegistry.SetKey(.cRegistryKey, 'ZoomFont',   .edtZoom.FontName)
		.oRegistry.SetKey(.cRegistryKey, 'ZoomFontSize', ;
			transform(.edtZoom.FontSize))
		.oRegistry.SetKey(.cRegistryKey, 'ZoomBold', ;
			transform(.edtZoom.FontBold, 'Y'))
		.oRegistry.GetKey(.cRegistryKey, 'ZoomItalic', ;
			transform(.edtZoom.FontItalic, 'Y'))
	endif not empty(.cRegistryKey)
endwith
dodefault()

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
cregistrykey The Registry key to use for settings
oregistry A reference to an SFRegistry object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0OX0VZQO9
[CLASS] sfcommandbutton
[CLASSLOC] sfctrls.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdFont
[PARENT] sfeditboxzoomform
[START PROPERTIES]
Caption = "Font..."
Name = "cmdFont"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
local lcStyle, ;
	lcFont, ;
	lnPos1, ;
	lnPos2
with This
	lcStyle = iif(.Parent.edtZoom.FontBold, 'B', '') + ;
		iif(.Parent.edtZoom.FontItalic, 'I', '')
	lcFont  = getfont(.Parent.edtZoom.FontName, .Parent.edtZoom.FontSize, ;
		lcStyle)
	if not empty(lcFont)
		lnPos1  = at(',', lcFont)
		lnPos2  = at(',', lcFont, 2)
		lcStyle = substr(lcFont, lnPos2 + 1)
		.Parent.edtZoom.FontName   = left(lcFont, lnPos1 - 1)
		.Parent.edtZoom.FontSize   = val(substr(lcFont, lnPos1 + 1, ;
			lnPos2 - lnPos1 - 1))
		.Parent.edtZoom.FontBold   = 'B' $ lcStyle
		.Parent.edtZoom.FontItalic = 'I' $ lcStyle
	endif not empty(lcFont)
endwith

ENDPROC
PROCEDURE Init
if type('oLocalizer.Name') = 'C'
	This.Caption = oLocalizer.GetLocalizedString('UI_CMD_FONT_LOC')
endif type('oLocalizer.Name') = 'C'
dodefault()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0N30ZFB8Q
[CLASS] sfeditbox
[CLASSLOC] sfctrls.vcx
[BASECLASS] editbox
[OBJNAME] edtZoom
[PARENT] sfeditboxzoomform
[START PROPERTIES]
AllowTabs = .T.
Height = 218
Name = "edtZoom"
Top = 30
Width = 375
lcanchangefont = .T.
lcanfind = .T.
lcanzoom = .F.
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfeditboxzoomform
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R6I0STXQF
[CLASS] form
[BASECLASS] form
[OBJNAME] sfform
[START PROPERTIES]
	<memberdata name="about" type="method" display="About"/>
	<memberdata name="activateobjectpage" type="method" display="ActivateObjectPage"/>
	<memberdata name="aerrorinfo" type="property" display="aErrorInfo"/>
	<memberdata name="afterrefresh" type="method" display="AfterRefresh" favorites="True"/>
	<memberdata name="anychange" type="method" display="AnyChange"/>
	<memberdata name="beforerefresh" type="method" display="BeforeRefresh" favorites="True"/>
	<memberdata name="builder" type="property" display="Builder"/>
	<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
	<memberdata name="canreleaseform" type="method" display="CanReleaseForm"/>
	<memberdata name="cleanup" type="method" display="Cleanup"/>
	<memberdata name="findactivecontrol" type="method" display="FindActiveControl"/>
	<memberdata name="finderrorhandler" type="method" display="FindErrorHandler"/>
	<memberdata name="handleerror" type="method" display="HandleError"/>
	<memberdata name="lchanged" type="property" display="lChanged"/>
	<memberdata name="lerrorinfosaved" type="property" display="lErrorInfoSaved"/>
	<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
	<memberdata name="lrelease" type="property" display="lRelease"/>
	<memberdata name="lsetfocustofirstobject" type="property" display="lSetFocusToFirstObject"/>
	<memberdata name="nborderstyle" type="property" display="nBorderStyle" favorites="True"/>
	<memberdata name="ninitialheight" type="property" display="nInitialHeight"/>
	<memberdata name="ninitialwidth" type="property" display="nInitialWidth"/>
	<memberdata name="nlasterror" type="property" display="nLastError"/>
	<memberdata name="ochanges" type="property" display="oChanges"/>
	<memberdata name="oerror" type="property" display="oError"/>
	<memberdata name="oexception" type="property" display="oException"/>
	<memberdata name="ohook" type="property" display="oHook"/>
	<memberdata name="omenu" type="property" display="oMenu"/>
	<memberdata name="omessage" type="property" display="oMessage"/>
	<memberdata name="outility" type="property" display="oUtility"/>
	<memberdata name="refreshform" type="method" display="RefreshForm"/>
	<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
	<memberdata name="resetchangedstate" type="method" display="ResetChangedState"/>
	<memberdata name="reseterror" type="method" display="ResetError"/>
	<memberdata name="seterror" type="method" display="SetError"/>
	<memberdata name="setfocustofirstobject" type="method" display="SetFocusToFirstObject"/>
	<memberdata name="setfocustolastobject" type="method" display="SetFocusToLastObject"/>
	<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
	<memberdata name="showmenu" type="method" display="ShowMenu"/>
	<memberdata name="updatechanges" type="method" display="UpdateChanges"/>

</VFPData>
AllowOutput = .F.
AutoCenter = .T.
Caption = "Form"
Desktop = .T.
DoCreate = .T.
FontName = "Tahoma"
KeyPreview = .T.
Name = "sfform"
ShowTips = .T.
ShowWindow = 1
_memberdata =     2971<VFPData>
builder = 
lchanged = .F.
lerrorinfosaved = .F.
lerroroccurred = .F.
lrelease = .F.
lsetfocustofirstobject = .T.
nborderstyle = 2
ninitialheight = 0
ninitialwidth = 0
nlasterror = 0
ochanges = .NULL.
oerror = .NULL.
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
omessage = .NULL.
outility = .NULL.
[END PROPERTIES]
[START PROTECTED]
calledfromthisclass
cleanup
lerrorinfosaved
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*==============================================================================
* Method:			Destroy
* Status:			Public
* Purpose:			Called when the object is being destroyed
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the form and any member objects are destroyed
*					if oApp exists, its CloseForm() method is called so it
*						knows we're no longer around
*==============================================================================

with This

* Hide the form so it appears to go away faster.

	.Hide()

* Cleanup as the object is destroyed.

	.Cleanup()

* Tell oApp we're closing.

	if type('oApp.Name') = 'C' and pemstatus(oApp, 'CloseForm', 5)
		oApp.CloseForm(.Name)
	endif type('oApp.Name') = 'C' ...
endwith

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Called when an error occurs in this object or a member
*						object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
* Last revision:	02/16/2003
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number where the error occurred
* Returns:			varies
* Environment in:	an error has occurred
*					This.oException may contain an Exception object
* Environment out:	control may be returned to the object/method that caused
*						the error (either as RETURN or RETRY) or to the routine
*						containing the READ EVENTS for the application
*					the form may be released
*					see This.SetError() and This.HandleError() for other
*						environmental changes
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcReturn, ;
	lcReturnToOnCancel, ;
	lnPos, ;
	lcObject
with This

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

	lcMethod = tcMethod
	lnLine   = tnLine
	lcSource = message(1)
	aerror(laError)
	if vartype(.oException) = 'O'
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'

* Use SetError() and HandleError() to gather error information and handle it.

	.SetError(lcMethod, lnLine, lcSource, @laError)
	.lErrorInfoSaved = .F.
	lcReturn = .HandleError()

* Figure out where to go if the user chooses "Cancel".

	do case
		case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
			upper(.Name)
			lcReturnToOnCancel = ''
		case type('.oError.cReturnToOnCancel') = 'C'
			lcReturnToOnCancel = .oError.cReturnToOnCancel
		case type('oError.cReturnToOnCancel') = 'C'
			lcReturnToOnCancel = oError.cReturnToOnCancel
		otherwise
			lcReturnToOnCancel = 'MASTER'
	endcase
endwith

* Handle the return value, depending on whether the error was "ours" or came
* from a member.

lnPos    = at('.', lcMethod)
lcObject = iif(lnPos = 0, '', upper(left(lcMethod, lnPos - 1)))
do case

* We're supposed to close the form, so do so and return to the master program
* (we'll just cancel if we *are* the master program).

	case lcReturn = ccMSG_CLOSEFORM
		This.Release()
		if empty(lcReturnToOnCancel)
			cancel
		else
			return to &lcReturnToOnCancel
		endif empty(lcReturnToOnCancel)

* This wasn't our error, so return the error resolution string.

	case lnPos > 0 and not (lcObject == upper(This.Name) or ;
		'DATAENVIRONMENT' $ upper(lcMethod))
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry.

	case lcReturn = ccMSG_RETRY
		retry

* If Cancel was chosen but the master program is this form, we'll just cancel.

	case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
		cancel

* Cancel was chosen, so return to the master program.

	case lcReturn = ccMSG_CANCEL
		return to &lcReturnToOnCancel

* Return to the routine in error to continue on.

	otherwise
		return
endcase

ENDPROC
PROCEDURE GotFocus
*==============================================================================
* Method:			GotFocus
* Status:			Public
* Purpose:			Called when the window receives focus
* Author:			Doug Hennig
* Copyright:		(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:	03/29/2010
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	if we're not being released, This.RefreshForm() is called
*						to ensure any BeforeRefresh and AfterRefresh behaviors
*						are triggered
*==============================================================================

if not This.lRelease
	This.RefreshForm()
endif not This.lRelease

ENDPROC
PROCEDURE Init
*==============================================================================
* Method:			Init
* Status:			Public
* Purpose:			Initializes the object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:	04/12/2010
* Parameters:		none
* Returns:			.T. if everything succeeded, or .F. if an error occurred
* Environment in:	none
* Environment out:	if This.Icon is empty, it's set to _screen.Icon
*					This.BorderStyle is set to This.nBorderStyle
*					This.oUtility may be set to an existing or may contain a
*						new SFUtility object
*					This.oMessage may be set to an existing or may contain a
*						new SFMessage object
*					This.oChanges contains a collection
*==============================================================================

local lcLibrary
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* If the Icon property is blank, grab the screen's or active form's.

	do case
		case not empty(.Icon)
		case _screen.Visible
			.Icon = _screen.Icon
		case type('_screen.ActiveForm.Name') = 'C'
			.Icon = _screen.ActiveForm.Icon
	endcase

* If the icon is still empty, _screen may have been invisible, so we'll use its
* icon anyway.

	if empty(.Icon)
		.Icon = _screen.Icon
	endif empty(.Icon)

* Set the BorderStyle property as desired. Note that we don't do this if a
* variable named __NOBORDER exists; this allows screen shots to show the window
* as it actually appears.

	if .BorderStyle <> .nBorderStyle and type('__NOBORDER') = 'U'
		.BorderStyle = .nBorderStyle
	endif .BorderStyle <> .nBorderStyle ...

* Get or create references to SFUtility and SFMessageMgr objects.

	lcLibrary = 'SFUtility.vcx'
	do case
		case type('.oUtility.Name') = 'C'
		case type('oUtility.Name') = 'C'
			.oUtility = oUtility
		case file(lcLibrary)
			.oUtility = newobject('SFUtility', lcLibrary)
	endcase
	lcLibrary = 'SFMessage.vcx'
	do case
		case type('.oMessage.Name') = 'C'
		case type('oMessage.Name') = 'C'
			.oMessage = oMessage
		case file(lcLibrary)
			.oMessage = newobject('SFMessageMgr', lcLibrary, '', .Caption)
	endcase

* Create a collection of changes made to the values of controls.

	.oChanges = createobject('Collection')
endwith
return not This.lErrorOccurred

ENDPROC
PROCEDURE KeyPress
lparameters tnKeyCode, ;
	tnShiftAltCtrl
do case

* Display the shortcut menu if Shift-F10 is pressed.

	case tnKeyCode = 93 and tnShiftAltCtrl = 1
		This.ShowMenu()

* Prevent Ctrl-0 from inserting a null value.

	case tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
		nodefault
endcase

ENDPROC
PROCEDURE Load
*==============================================================================
* Method:			Load
* Status:			Public
* Purpose:			Sets up environmental things before the form instantiates
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	04/25/2005
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the environment is set up the way we want
*					the locations of tables in the DataEnvironment may have
*						been changed
*==============================================================================

with This

* Set some environmental things the way we want if we're in a private
* datasession. These are in alphabetical order. Not all are datasession-
* specific, but we'll set 'em anyway.

	if .DataSession = 2
		set ansi       off
		set bell       off			&& not datasession-specific
		set compatible off			&& not datasession-specific
		set cpdialog   off			&& not datasession-specific
		set deleted    on
		set exact      off
		set exclusive  off
		set fullpath   on			&& not datasession-specific
		set multilocks on
		set near       off
		set notify     off			&& not datasession-specific
		set nulldisplay to ''		&& not datasession-specific
		set safety     off
		set talk       off
		set unique     off

* Set CENTURY after SYSFORMATS, since SYSFORMATS changes CENTURY.

		set sysformats on
		set century    on
	endif .DataSession = 2

* If the tables haven't been opened yet, set the data directory for all
* databases and free tables, then open the tables. If we don't have an
* application object, just open the tables.

	do case
		case type('.DataEnvironment') <> 'O' or ;
			.DataEnvironment.AutoOpenTables
		case type('oApp.Name') = 'C' and pemstatus(oApp, 'SetDataDirectory', 5)
			oApp.SetDataDirectory(.DataEnvironment)
			.DataEnvironment.OpenTables()
		otherwise
			.DataEnvironment.OpenTables()
	endcase

* Save the initial width and height values; we may need them later for resizing
* purposes.

	.nInitialWidth  = .Width
	.nInitialHeight = .Height
endwith

ENDPROC
PROCEDURE QueryUnload
*==============================================================================
* Method:			QueryUnload
* Status:			Public
* Purpose:			See if we can close the form and if not, use NODEFAULT to
*						prevent it
* Author:			Doug Hennig
* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:	04/07/2008
* Parameters:		none
* Returns:			.T. if the form can be closed
* Environment in:	none
* Environment out:	see This.CanReleaseForm
*==============================================================================

local llReturn
llReturn = This.CanReleaseForm()
if not llReturn
	nodefault
endif not llReturn
return llReturn

ENDPROC
PROCEDURE Release
* Release the object. Note the avoidance of "with This" in this code to prevent
* potential problems with dangling object references.

* Do nothing if we're already in the process of releasing or CanReleaseForm
* says we can't release.

if This.lRelease or not This.CanReleaseForm()
	nodefault
	return .F.
endif This.lRelease ...

* Do cleanup tasks.

This.Cleanup()

ENDPROC
PROCEDURE RightClick
*==============================================================================
* Method:			RightClick
* Status:			Public
* Purpose:			Display a right-click menu
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	03/16/98
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	a menu may have been displayed and action taken from the
*						choice the user made
*==============================================================================

This.ShowMenu()

ENDPROC
PROCEDURE Show
*==============================================================================
* Method:			Show
* Status:			Public
* Purpose:			Display the form
* Author:			Doug Hennig
* Copyright:		(c) 1996-2009 Stonefield Systems Group Inc.
* Last revision:	09/14/2009
* Parameters:		tnStyle - the style for the window
* Returns:			.T.
* Environment in:	none
* Environment out:	focus is set to the first object in the form
*==============================================================================

lparameters tnStyle
local lcDataType
lcDataType = vartype(tnStyle)
if (pcount() = 0 or lcDataType = 'L' or (lcDataType = 'N' and tnStyle = ;
	This.WindowType)) and This.lSetFocusToFirstObject
	This.SetFocusToFirstObject(This)
endif pcount() = 0 ...

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFForm
* Based On:						Form
* Purpose:						Base class for all Form objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:				04/12/2010
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	AllowOutput:				.F.
*	AutoCenter:					.T.
*	Desktop:					.T. so windows use Aero Glass in Vista
*	FontName:					Tahoma
*	KeyPress:					.T.
*	ShowTips:					.T.
*	ShowWindow:					1 - In Top-level Form
*
* Changes in "Based On" class methods:
*	Destroy:					hides the form so it disappears faster, and
*								clean up other things
*	Error:						calls This.SetError and This.HandleError
*	GotFocus:					calls This.RefreshForm
*	Init:						puts the value of the custom nBorderStyle
*								property into the BorderStyle property.
*								Instantiate SFUtility and SFMessageMgr objects
*								if necessary. Instantiate a collection into
*								This.oChanges. Change FontName to Segoe UI in
*								Vista
*	KeyPress:					call This.ShowMenu if Shift-F10 is pressed
*	Load:						set up the environment the way we want
*	QueryUnload:				call CanReleaseForm to see if the form can be
*								released
*	Release:					call This.Cleanup
*	RightClick:					call This.ShowMenu
*	Show:						call This.SetFocusToFirstObject so focus goes
*								to the first object in the form
*
* Custom public properties added:
*	aErrorInfo:					an array of error information
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lChanged:					.T. if something in the form has changed
*	lErrorOccurred:				.T. if an error occurred (set in SetError)
*	lRelease:					.T. as the object is being released
*	lSetFocusToFirstObject   	.T. to set focus to the first object in Show
*	nBorderStyle:				the value (default = 2, Fixed dialog) to put
*								into the BorderStyle property at runtime
*	nInitialHeight:				the initial height of the form
*	nInitialWidth:				the initial width of the form
*	nLastError:					the index to the last error that occurred in
*								aErrorInfo
*	oChanges:					a reference to a collection of changes
*	oError:						a reference to an error handling object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*	oMessage:					a reference to an SFMessageMgr object
*	oUtility:					a reference to an SFUtility object
*
* Custom protected properties added:
*	lErrorInfoSaved:			.T. if the error information has been saved in
*								aErrorInfo
*
* Custom public methods added:
*	About:						provides documentation for the class
*	ActivateObjectPage:			ensures any page the specified object is
*								sitting on is the active page
*	AfterRefresh:				an abstract method of code to execute after a
*								form is refreshed
*	AnyChange:					this method can be called when anything in the
*								form changes
*	BeforeRefresh:				an abstract method of code to execute before a
*								form is refreshed
*	CanReleaseForm:				returns .T. if we can release the form
*	FindActiveControl:			returns a reference to the active control
*								(which may be in a container)
*	FindErrorHandler:			called by the Error method of contained objects
*								to find a parent that has code in its Error
*								method
*	HandleError:				handles an error
*	RefreshForm:				refreshes the form
*	ReleaseMembers:				abstract method to nuke member references
*	ResetChangedState:			resets the changed state
*	ResetError:					resets lErrorOccurred, aErrorInfo, and
*								nLastError
*	SetError:					sets lErrorOccurred and aErrorInfo to
*								information about the most recent error
*	SetFocusToFirstObject:		sets focus to the first object in the specified
*								container
*	SetFocusToLastObject:		sets focus to the last object in the specified
*								container
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateChanges:				adjusts the oChanges collection when a change
*								is made
*
* Custom protected methods added:
*	CalledFromThisClass:		returns .T. if a method was called from this
*								class
*	Cleanup:					cleans up member references when the object is
*								released or destroyed
*==============================================================================

ENDPROC
PROCEDURE activateobjectpage
*==============================================================================
* Method:			ActivateObjectPage
* Status:			Public
* Purpose:			Ensures any page the specified object is sitting on is the
*						active page
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/04/98
* Parameters:		toObject - an object reference to the desired object
* Returns:			.T.
* Environment in:	none
* Environment out:	any page (even if the object is in a container on a
*						pageframe on a pageframe) the specified object is
*						sitting on is the active page
*==============================================================================

lparameters toObject
local loParent, ;
	lnPage

* Ensure the passed parameter is a contained object.

if vartype(toObject) <> 'O' or type('toObject.Parent') <> 'O'
	error 'Parameter is not a contained object.'
	return .F.
endif vartype(toObject) <> 'O' ...
loParent = toObject.Parent
lnPage   = 0

* Drill up until we hit the form, activating pages as necessary.

do while upper(loParent.BaseClass) <> 'FORM'
	do case
		case upper(loParent.BaseClass) == 'PAGE'
			lnPage = loParent.PageOrder
		case upper(loParent.BaseClass) == 'PAGEFRAME' and ;
			loParent.ActivePage <> lnPage
			loParent.ActivePage = lnPage
	endcase
	loParent = loParent.Parent
enddo while upper(loParent.BaseClass) <> 'FORM'

ENDPROC
PROCEDURE afterrefresh
* Abstract method

ENDPROC
PROCEDURE anychange
* Flag that something changed.

This.lChanged = .T.

ENDPROC
PROCEDURE beforerefresh
* Abstract method

ENDPROC
PROCEDURE calledfromthisclass
*==============================================================================
* Method:			CalledFromThisClass
* Status:			Protected
* Purpose:			Determines if the method that called this method was called
*						from a method of this class or an ancestor
* Author:			Doug Hennig
* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
* Last Revision:	08/22/2000
* Parameters:		none
* Returns:			.T. if the method that called this method was called from a
*						method of this class or an ancestor
* Environment in:	none
* Environment out:	none
* Notes:			The reason we want to know if the method that called this
*						method was called from a method of this class or not is
*						to permit "read-only" properties to be changed only by
*						methods of this class. This would typically be called
*						from an Assign method, such as:
*
*					lparameters tuNewValue
*					if This.CalledFromThisClass()
*						This.<property> = tuNewValue
*					else
*						error 1743, '<property>'   && property is read-only
*					endif This.CalledFromThisClass()
*==============================================================================

local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn

* Get the name of the program that called us, and get the object name from it.

lnLevel   = program(-1)
lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI
return llReturn

ENDPROC
PROCEDURE canreleaseform
* Abstract method

ENDPROC
PROCEDURE cleanup
*==============================================================================
* Method:			Cleanup
* Status:			Protected
* Purpose:			Nuke member objects
* Author:			Doug Hennig
* Copyright:		(c) 1998 Stonefield Systems Group Inc.
* Last Revision:	03/04/2000
* Parameters:		none
* Returns:			.T. if everything succeeded
* Environment in:	This.lRelease is .T. if we're already in the process of
*						releasing
* Environment out:	This.lRelease is .T.
*					This.oHook, oError, and oMenu are .NULL.
*					This.ReleaseMembers() was called
* Notes:			This methods avoids use of "with This" to prevent potential
*						problems with dangling object references
*==============================================================================

if This.lRelease
	return .F.
endif This.lRelease
This.lRelease = .T.
This.ReleaseMembers()
This.oHook    = .NULL.
This.oError   = .NULL.
This.oMenu    = .NULL.
This.oMessage = .NULL.
This.oUtility = .NULL.

ENDPROC
PROCEDURE findactivecontrol
*==============================================================================
* Method:			FindActiveControl
* Status:			Public
* Purpose:			Returns a reference to the active control (which may be in
*						a container)
* Author:			Doug Hennig
* Copyright:		(c) 2002-2008 Stonefield Systems Group Inc.
* Last revision:	05/22/2008
* Parameters:		toContainer - the container to check (optional: if it isn't
*						passed, the form is used)
* Returns:			a reference to the active control if there is one or .NULL.
*						if not
* Environment in:	none
* Environment out:	none
*==============================================================================

lparameters toContainer
local loContainer, ;
	loObject, ;
	loControl

* If the container wasn't specified, let's use the form.

loContainer = iif(vartype(toContainer) = 'O', toContainer, This)

* If we've found the active control, get a reference to it.

loObject = .NULL.
if type('loContainer.ActiveControl.Name') = 'C'
	loObject = loContainer.ActiveControl

* We didn't find the active control, so check every member container by calling
* ourselves recursively.

else
	for each loControl in loContainer.Objects foxobject
		if pemstatus(loControl, 'ActiveControl', 5) or ;
			pemstatus(loControl, 'Objects', 5)
			This.FindActiveControl(loControl)
		endif pemstatus(loControl, 'ActiveControl', 5) ...
	next loControl
endif type('loContainer.ActiveControl.Name') = 'C'
return loObject

ENDPROC
PROCEDURE finderrorhandler
*==============================================================================
* Method:			FindErrorHandler
* Status:			Public
* Purpose:			Travel up the containership hierarchy until we find a
*						parent for the specified object that has code in its
*						Error method
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	04/02/2002
* Parameters:		toObject - an object reference to the desired object
* Returns:			an object reference to the first parent of the specified
*						object that has code in its Error method if one could
*						be found, or .NULL. if not
* Environment in:	none
* Environment out:	none
* Note:				This method prevents a problem with controls sitting on
*						base class Page or Column objects -- no error trapping
*						gets done if no custom code is directly entered into
*						these objects
*
*					This mechanism only works in the VFP development
*						environment or in an APP/EXE with debug info turned on
*==============================================================================

lparameters toObject
local loParent
loParent = toObject.Parent
do while vartype(loParent) = 'O'
	do case
		case pemstatus(loParent, 'Error', 0)
			exit
		case type('loParent.Parent') = 'O'
			loParent = loParent.Parent
		otherwise
			loParent = .NULL.
	endcase
enddo while vartype('loParent') = 'O'

* If we couldn't find a valid parent object (likely because we're running in an
* EXE with debug info turned off, let's return ourselves.

if isnull(loParent)
	loParent = This
endif isnull(loParent)
return loParent

ENDPROC
PROCEDURE handleerror
*==============================================================================
* Method:			HandleError
* Status:			Public
* Purpose:			Handles an error
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/14/2005
* Parameters:		none
* Returns:			a string indicating the error resolution; see SFERRORS.H
*						for the possible values
* Environment in:	This.nLastError points to the row in This.aErrorInfo that
*						has information about the current error
* Environment out:	an error message may have been displayed, or some other
*						error resolution may have been taken
* Notes:			if This.oError contains an error handling object, its
*						ErrorHandler method is called
*					if a global oError contains an error handling object, its
*						ErrorHandler method is called
*					if an ON ERROR routine is in effect, it's called
*					if none of these is true, a generic error message is
*						displayed
*==============================================================================

local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcErrorMessage, ;
	lcErrorInfo, ;
	lcSource, ;
	loError, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice
with This
	lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
	lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
	lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
	lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
	lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
	lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]

* Get a reference to our error handling object if there is one. It could either
* be a member of the form or a global object.

	do case
		case vartype(.oError) = 'O'
			loError = .oError
		case type('oError.Name') = 'C'
			loError = oError
		otherwise
			loError = .NULL.
	endcase
	do case

* If the error is "cannot set focus during valid" or "DataEnvironment already
* unloaded", we'll let it go.

		case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
			lcReturn = ccMSG_CONTINUE

* We have an error handling object, so call its ErrorHandler() method.

		case not isnull(loError)
			lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

		case not empty(on('ERROR'))
			lcError = upper(on('ERROR'))
			lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
			lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
			lcError = strtran(lcError, ',ERROR()',  ',lnError')
			lcError = strtran(lcError, ' ERROR()',  ' lnError')
			lcError = strtran(lcError, 'LINENO()',  'lnLine')
			lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
			lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

			if left(lcError, 3) = 'DO ' or '=' $ lcError
				&lcError
				lcReturn = ccMSG_CONTINUE
			else
				lcReturn = &lcError
			endif left(lcError, 3) = 'DO ' ...

* We don't have an error handling object, so display a dialog box.

		otherwise
			lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
				ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
				iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
				ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
				transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
			if version(2) = 0
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose OK to continue or Cancel to cancel execution', ;
					MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
			else
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
			endif version(2) = 0
			lcReturn = ccMSG_CONTINUE
			do case
				case lnChoice = IDYES
					lcReturn = ccMSG_DEBUG
				case lnChoice = IDCANCEL
					lcReturn = ccMSG_CANCEL
			endcase
	endcase
endwith
lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
	ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
return lcReturn

ENDPROC
PROCEDURE refreshform
*==============================================================================
* Method:			RefreshForm
* Status:			Public
* Purpose:			Refreshes the form
* Author:			Doug Hennig
* Copyright:		(c) 1996-2006 Stonefield Systems Group Inc.
* Last revision:	01/10/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the form has been refreshed and any code in the
*						BeforeRefresh and AfterRefresh methods has executed
* Notes:			LockWindowUpdate was formerly used instead of
*						This.LockScreen as a workaround for the problem of
*						labels becoming bolder and bolder when this method is
*						called (caused by a bug in how VFP works with ClearType
*						displays) but that causes too much Windows Desktop
*						refreshing, so we've reverted to LockScreen.
*==============================================================================

with This
	.LockScreen = .T.
	.BeforeRefresh()
	.Refresh()
	.AfterRefresh()
	.LockScreen = .F.
endwith

ENDPROC
PROCEDURE releasemembers
* Abstract method

ENDPROC
PROCEDURE resetchangedstate
* Reset the changed state.

This.lChanged = .F.
This.oChanges.Remove(-1)

ENDPROC
PROCEDURE reseterror
*==============================================================================
* Method:			ResetError
* Status:			Public
* Purpose:			Reset lErrorOccurred and aErrorInfo
* Author:			Doug Hennig
* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
* Last revision:	01/26/2003
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	This.lErrorOccurred is .F.
*					This.nLastError is 1
*					This.aErrorInfo is dimensioned to a single blank row
*					This.oException is null
*==============================================================================

with This
	.lErrorOccurred = .F.
	dimension .aErrorInfo[1, cnAERR_MAX]
	.aErrorInfo = ''
	.nLastError = 1
	.oException = .NULL.
endwith

ENDPROC
PROCEDURE seterror
*==============================================================================
* Method:			SetError
* Status:			Public
* Purpose:			Handle errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2006 Stonefield Systems Group Inc.
* Last revision:	04/26/2006
* Parameters:		tcMethod - the method or function the error occurred in
*					tnLine   - the line number within tcMethod
*					tcSource - the code causing the error
*					taError  - an array of error information
* Returns:			.T.
* Environment in:	This.aErrorInfo is dimensioned appropriately
*					This.lErrorSet is .T. if this method has already been called
*						for this error
* Environment out:	This.lErrorOccurred is .T.
*					This.lErrorSet is .T.
*					This.nLastError points to the current row in This.aErrorInfo
*					This.aErrorInfo is filled with error information as
*						follows:
*
*					Column	Information
*					------	-----------
*					1 - 7	same as AERROR()
*					8		method error occurred in
*					9		line error occurred on
*					10		code causing error
*					11		date/time error occurred
*					12		not used
*					13		XML string of properties and their values for the
*							object that caused the error (may be blank)
*==============================================================================

lparameters tcMethod, ;
	tnLine, ;
	tcSource, ;
	taError
local lnRows, ;
	lnCols, ;
	lnLast, ;
	lnError, ;
	lnRow, ;
	lnI
external array taError
with This

* If we've already been called, just update the method information.

	if .lErrorInfoSaved
		.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
	else

* Flag that an error occurred.

		.lErrorOccurred  = .T.
		.lErrorInfoSaved = .T.
		lnRows = alen(taError, 1)
		lnCols = alen(taError, 2)
		lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
		dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]

* For each row in the error array, put each column into our array.

		for lnError = 1 to lnRows
			lnRow = lnLast + lnError
			for lnI = 1 to lnCols
				.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
			next lnI

* Add some additional information to the current row in our array.

			.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
			.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
			.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
				iif(tcSource = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
				tcSource)
			.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
		next lnError
		.nLastError = alen(.aErrorInfo, 1)
	endif not .lErrorInfoSaved
endwith

ENDPROC
PROCEDURE setfocustofirstobject
*==============================================================================
* Method:			SetFocusToFirstObject
* Status:			Public
* Purpose:			Sets focus to the first object in the specified container
* Author:			Doug Hennig
* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:	11/14/2008
* Parameters:		toContainer       - the container to check (optional: if it
*						isn't passed, the form is used)
*					tlKeepCurrentPage - .T. to keep the current page in any
*						PageFrame active
* Returns:			.T. if it set focus to an object
* Environment in:	none
* Environment out:	if this method returns .T., focus has been set to an object
*==============================================================================

lparameters toContainer, ;
	tlKeepCurrentPage
local loContainer, ;
	laObjects[1], ;
	lnObjects, ;
	lnIndex, ;
	loControl, ;
	llReturn, ;
	lnI, ;
	loObject, ;
	lcClass, ;
	lnPage, ;
	loPage

* If the container wasn't specified, let's use the form.

loContainer = iif(vartype(toContainer) = 'O', toContainer, This)

* Get an array of all member objects of the specified container. Initialize
* some variables.

lnObjects = amembers(laObjects, loContainer, 2)
lnIndex   = 99999
loControl = .NULL.
llReturn  = .F.

* Check each of the member objects until we come across the one lowest in the
* tab order.

for lnI = 1 to lnObjects
	loObject = evaluate('loContainer.' + laObjects[lnI])
	lcClass  = upper(loObject.BaseClass)
	do case

* If the object doesn't have a TabIndex property, is a label, is disabled, is
* read-only, or isn't visible, ignore it.

		case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
			(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
				upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
			(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
			(type('loObject.ReadOnly') = 'L' and loObject.ReadOnly) or ;
			(type('loObject.Visible') = 'L' and not loObject.Visible)

* If this object is lower in tab order than any we've already seen, grab a
* reference to it.

		case loObject.TabIndex < lnIndex
			loControl = loObject
			lnIndex   = loObject.TabIndex
	endcase
next lnI

* If we found an object, set focus to it. We may need to drill down into it if
* it's a container.

if vartype(loControl) = 'O'
	lcClass = upper(loControl.BaseClass)
	do case

* If this is a pageframe, choose the first page, then call ourselves
* recursively to find the first object inside it and set focus to it.

		case lcClass = 'PAGEFRAME'
			if tlKeepCurrentPage
				lnPage = loControl.ActivePage
			else
				lnIndex = 99999
				lnPage  = 0
				for lnI = 1 to loControl.PageCount
					loPage = loControl.Pages[lnI]
					if loPage.PageOrder < lnIndex
						lnPage  = lnI
						lnIndex = loPage.PageOrder
					endif loPage.PageOrder < lnIndex
				next lnI
			endif tlKeepCurrentPage
			if lnPage > 0
				if loControl.ActivePage <> lnPage
					loControl.ActivePage = lnPage
				endif loControl.ActivePage <> lnPage
				llReturn = This.SetFocusToFirstObject(loControl.Pages[lnPage])
			endif lnPage > 0

* If this is another type of container, call ourselves recursively to find the
* first object inside it and set focus to it.

		case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
			llReturn = This.SetFocusToFirstObject(loControl)

* Set focus to the object.

		case pemstatus(loControl, 'SetFocus', 5)
			loControl.SetFocus()
			llReturn = .T.
	endcase
endif vartype(loControl) = 'O' ...
return llReturn

ENDPROC
PROCEDURE setfocustolastobject
*==============================================================================
* Method:			SetFocusToLastObject
* Status:			Public
* Purpose:			Sets focus to the last object in the specified container
* Author:			Doug Hennig
* Copyright:		(c) 2008 Stonefield Systems Group Inc.
* Last revision:	11/14/2008
* Parameters:		toContainer       - the container to check (optional: if it
*						isn't passed, the form is used)
*					tlKeepCurrentPage - .T. to keep the current page in any
*						PageFrame active
* Returns:			.T. if it set focus to an object
* Environment in:	none
* Environment out:	if this method returns .T., focus has been set to an object
*==============================================================================

lparameters toContainer, ;
	tlKeepCurrentPage
local loContainer, ;
	laObjects[1], ;
	lnObjects, ;
	lnIndex, ;
	loControl, ;
	llReturn, ;
	lnI, ;
	loObject, ;
	lcClass, ;
	lnPage, ;
	loPage

* If the container wasn't specified, let's use the form.

loContainer = iif(vartype(toContainer) = 'O', toContainer, This)

* Get an array of all member objects of the specified container. Initialize
* some variables.

lnObjects = amembers(laObjects, loContainer, 2)
lnIndex   = 0
loControl = .NULL.
llReturn  = .F.

* Check each of the member objects until we come across the one lowest in the
* tab order.

for lnI = 1 to lnObjects
	loObject = evaluate('loContainer.' + laObjects[lnI])
	lcClass  = upper(loObject.BaseClass)
	do case

* If the object doesn't have a TabIndex property, is a label, is disabled, is
* read-only, or isn't visible, ignore it.

		case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
			(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
				upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
			(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
			(type('loObject.ReadOnly') = 'L' and loObject.ReadOnly) or ;
			(type('loObject.Visible') = 'L' and not loObject.Visible)

* If this object is greater in tab order than any we've already seen, grab a
* reference to it.

		case loObject.TabIndex > lnIndex
			loControl = loObject
			lnIndex   = loObject.TabIndex
	endcase
next lnI

* If we found an object, set focus to it. We may need to drill down into it if
* it's a container.

if vartype(loControl) = 'O'
	lcClass = upper(loControl.BaseClass)
	do case

* If this is a pageframe, choose the first page, then call ourselves
* recursively to find the first object inside it and set focus to it.

		case lcClass = 'PAGEFRAME'
			if tlKeepCurrentPage
				lnPage = loControl.ActivePage
			else
				lnIndex = 99999
				lnPage  = 0
				for lnI = 1 to loControl.PageCount
					loPage = loControl.Pages[lnI]
					if loPage.PageOrder < lnIndex
						lnPage  = lnI
						lnIndex = loPage.PageOrder
					endif loPage.PageOrder < lnIndex
				next lnI
			endif tlKeepCurrentPage
			if lnPage > 0
				if loControl.ActivePage <> lnPage
					loControl.ActivePage = lnPage
				endif loControl.ActivePage <> lnPage
				llReturn = This.SetFocusToLastObject(loControl.Pages[lnPage])
			endif lnPage > 0

* If this is another type of container, call ourselves recursively to find the
* last object inside it and set focus to it.

		case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
			llReturn = This.SetFocusToLastObject(loControl)

* Set focus to the object.

		case pemstatus(loControl, 'SetFocus', 5)
			loControl.SetFocus()
			llReturn = .T.
	endcase
endif vartype(loControl) = 'O' ...
return llReturn

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object (abstract in this
*						class)
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items may have been added to the menu in a
*						subclass of this class
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatechanges
* Update the collection of changes. If the specified item isn't in the
* collection, add it. If it was previously in the collection but has been
* reverted, remove it. Return .T. if there are any items in the collection
* (that is, there have been changes).

lparameters tcItem, ;
	tlChanged
local lnIndex, ;
	llReturn
lnIndex = This.oChanges.GetKey(tcItem)
do case
	case lnIndex = 0 and tlChanged
		This.oChanges.Add(.T., tcItem)
	case lnIndex > 0 and not tlChanged
		This.oChanges.Remove(tcItem)
endcase
llReturn = This.oChanges.Count > 0
return llReturn

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*activateobjectpage Ensures any page the specified object is sitting on is the active page
*afterrefresh An abstract method of code to execute after a form is refreshed
*anychange This method can be called when anything in the form changes
*beforerefresh An abstract method of code to execute before a form is refreshed
*calledfromthisclass Returns .T. if a method was called from this class
*canreleaseform Returns .T. if we can release the form
*cleanup Cleans up member references when the object is released or destroyed
*findactivecontrol Returns a reference to the active control (which may be in a container)
*finderrorhandler Find the first parent for a specified object that has code in its Error method
*handleerror Handles an error
*refreshform Refreshes the form
*releasemembers Abstract method to nuke member references
*resetchangedstate Resets the changed state
*reseterror Resets lErrorOccurred and aErrorInfo
*seterror Sets lErrorOccurred and aErrorInfo to information about the most recent error
*setfocustofirstobject Sets focus to the first object in the specified container
*setfocustolastobject Sets focus to the last object in the specified container
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatechanges Adjusts the oChanges collection when a change is made
^aerrorinfo[1,0] An array of error information
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lchanged .T. if something in the form has changed
lerrorinfosaved .T. if the error information has been saved in aErrorInfo
lerroroccurred .T. if an error occurred (set in SetError)
lrelease .T. as the object is being released
lsetfocustofirstobject .T. to set focus to the first object in Show
nborderstyle The value to put into the BorderStyle property at runtime *** 0=No border,1=Fixed single,2=Fixed dialog,3=Sizable
ninitialheight The initial height of the form
ninitialwidth The initial width of the form
nlasterror The index to the last error that occurred in aErrorInfo
ochanges A reference to a collection of changes
oerror A reference to an error handling object
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu An object reference to a shortcut menu object
omessage A reference to an SFMessageMgr object
outility A reference to an SFUtility object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for Form objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfform
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2LW0Z2YKO
[CLASS] sfform
[CLASSLOC] sfctrls.vcx
[BASECLASS] form
[OBJNAME] sfformtlf
[START PROPERTIES]
DoCreate = .T.
Name = "sfformtlf"
ShowWindow = 2
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfformtlf
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RD812R17V
[CLASS] grid
[BASECLASS] grid
[OBJNAME] sfgrid
[START PROPERTIES]
	<memberdata name="about" type="method" display="About"/>
	<memberdata name="builder" type="property" display="Builder"/>
	<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
	<memberdata name="getcaption" type="method" display="GetCaption"/>
	<memberdata name="lautofit" type="property" display="lAutoFit" favorites="True"/>
	<memberdata name="lautosetcolor" display="lAutoSetColor"/></VFPData>
	<memberdata name="lautosetup" type="property" display="lAutoSetup" favorites="True"/>
	<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
	<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
	<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
	<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
	<memberdata name="nbackcolor" type="property" display="nBackColor"/>
	<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
	<memberdata name="oexception" type="property" display="oException"/>
	<memberdata name="ohook" type="property" display="oHook"/>
	<memberdata name="omenu" type="property" display="oMenu"/>
	<memberdata name="onformchange" type="method" display="OnFormChange"/>
	<memberdata name="release" type="method" display="Release"/>
	<memberdata name="setupcolumns" type="method" display="SetupColumns"/>
	<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
	<memberdata name="showmenu" type="method" display="ShowMenu"/>
AllowHeaderSizing = .F.
AllowRowSizing = .F.
Anchor = 15
FontName = "Tahoma"
Name = "sfgrid"
SplitBar = .F.
_memberdata =     1548<VFPData>
builder = 
lautofit = .F.
lautosetcolor = .T.
lautosetup = .T.
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nbackcolor = 0
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nbackcolor
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
local loParent
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* Use system colors if we're supposed to.

	if .lAutoSetColor
		#define COLOR_HIGHLIGHT     13
		#define COLOR_HIGHLIGHTTEXT 14
		declare integer GetSysColor in 'user32' integer nIndex
		.HighlightBackColor = GetSysColor(COLOR_HIGHLIGHT)
		.HighlightForeColor = GetSysColor(COLOR_HIGHLIGHTTEXT)
	endif .lAutoSetColor

* Call the SetupColumns method so we can handle highlighting the entire row if
* necessary.

	if .lAutoSetup
		.SetupColumns()
	endif .lAutoSetup

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE Refresh
* Ensure all contained controls are refreshed.

local loColumn, ;
	loControl
with This
	for each loColumn in .Columns foxobject
		for each loControl in loColumn.Controls foxobject
			if pemstatus(loControl, 'Refresh', 5)
				loControl.Refresh()
			endif pemstatus(loControl, 'Refresh', 5)
		next loControl
	next loColumn
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFGrid
* Based On:						Grid
* Purpose:						Base class for all Grid objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2009 Stonefield Systems Group Inc.
* Last revision:				06/25/2009
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	AllowHeaderSizing:			.F.
*	AllowRowSizing:				.F.
*	Anchor:						15 (resize height and width)
*	FontName:					Tahoma
*	SplitBar:					.F.
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						call This.SetupColumns and bind OnFormChange to
*								the form's lChanged property if necessary.
*								Change FontName to Segoe UI in Vista.
*	Refresh:					refresh contained controls
*	RightClick:					call This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lAutoFit:					.T. to auto-fit the columns automatically
*	lAutoSetColor:				.T. to automatically use system colors
*	lAutoSetup:					.T. to automatically call SetupColumns from
*								Init
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nBackColor:					our original BackColor
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	Enabled_Assign:				makes the grid appear enabled or disabled
*	GetCaption:					gets the caption for the specified field
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	SetupColumns:				sets up things we need about columns
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE enabled_assign
* Make the grid appear to be disabled if necessary.

lparameters tlEnabled
with This
	do case
		case .Enabled = tlEnabled
		case tlEnabled
			.BackColor = iif(.nBackColor = 0, .BackColor, .nBackColor)
		otherwise
			.nBackColor = .BackColor
			.BackColor  = .Parent.BackColor
	endcase
	.Enabled = tlEnabled
endwith

ENDPROC
PROCEDURE getcaption
*==============================================================================
* Method:			GetCaption
* Status:			Public
* Purpose:			Get the caption for the specified field
* Author:			Doug Hennig
* Copyright:		(c) 1996-1998 Stonefield Systems Group Inc.
* Last revision:	12/04/98
* Parameters:		tcField - the field to get the caption for
* Returns:			the caption for the field
* Environment in:	if the field's table is in a DBC, that DBC is the current
*						one
*					oMeta may contain an object reference to DBCXMgr
* Environment out:	none
*==============================================================================

lparameters tcField
local lcField, ;
	lcCaption
lcField = substr(tcField, at('.', tcField) + 1)
do case
	case not empty(dbc()) and indbc(tcField, 'Field')
		lcCaption = dbgetprop(tcField, 'Field', 'Caption')
	case vartype('oMeta') = 'O'
		lcCaption = nvl(oMeta.DBCXGetProp(tcField, 'Field', 'Caption'), '')
	otherwise
		lcCaption = ''
endcase
lcCaption = iif(empty(lcCaption), proper(strtran(lcField, '_', ' ')), ;
	lcCaption)
return lcCaption

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE setupcolumns
*==============================================================================
* Method:			SetupColumns
* Status:			Public
* Purpose:			Sets up the columns
* Author:			Doug Hennig
* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:	05/22/2008
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	if the table belongs to a database, that database is the
*						current one
*					headers with a default caption are changed to the caption
*						for the field their column displays
*					the FontName and FontSize for all headers is set to that of
*						the grid
*==============================================================================

local lcDatabase, ;
	loColumn, ;
	lcCaption
with This

* If the grid is read-only, make all member objects read-only.

	if .ReadOnly
		.SetAll('ReadOnly', .T.)
	endif .ReadOnly

* Ensure the database for the RecordSource (if there is one) is selected. This
* is needed for the GetCaption method.

	if not empty(.RecordSource)
		lcDatabase = cursorgetprop('DATABASE', .RecordSource)
		if not set('DATABASE') == lcDatabase and not empty(lcDatabase)
			set database to (lcDatabase)
		endif not set('DATABASE') == lcDatabase ...
	endif not empty(.RecordSource)

* Ensure each column has a valid header caption.

	for each loColumn in .Columns foxobject
		for each loObject in loColumn.Controls foxobject
			if upper(loObject.BaseClass) = 'HEADER'
				if loObject.Caption = 'Header1' and ;
					not empty(loColumn.ControlSource)
					lcCaption = .GetCaption(loColumn.ControlSource)
					loObject.Caption = lcCaption
				endif loObject.Caption = 'Header1' ...
				loObject.FontName = .FontName
				loObject.FontSize = .FontSize
				exit
			endif upper(loObject.BaseClass) = 'HEADER'
		next loObject
	next loColumn

* If we're supposed to auto-fit the columns, do so.

	if .lAutoFit
		.AutoFit()
	endif .lAutoFit
endwith

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*enabled_assign Makes the grid appear enabled or disabled
*getcaption Gets the caption for the specified field
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*setupcolumns Sets up things we need about columns
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lautofit .T. to auto-fit the columns automatically
lautosetcolor .T. to automatically use system colors
lautosetup .T. to automatically call SetupColumns from Init
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nbackcolor Our original BackColor
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for Grid objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfgrid
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCX18PYVW
[CLASS] image
[BASECLASS] image
[OBJNAME] sfimage
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
BackStyle = 0
Name = "sfimage"
_memberdata =      999<VFPData>
builder = 
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
* If we're supposed to bind to the lChanged property of the form, do so.

if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
	pemstatus(Thisform, 'lChanged', 5)
	bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
endif This.lNotifyOnFormChange ...

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFImage
* Based On:						Image
* Purpose:						Base class for all Image objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:				12/15/2005
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	BackStyle:					0 (Transparent)
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T.
*	RightClick:					call This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for Image objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfimage

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCS0T3PHQ
[CLASS] label
[BASECLASS] label
[OBJNAME] sflabel
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
AutoSize = .T.
BackStyle = 0
Caption = "Label1"
FontName = "Tahoma"
Name = "sflabel"
_memberdata =     1033<VFPData>
builder = 
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .T.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFLabel
* Based On:						Label
* Purpose:						Base class for all Label objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2007 Stonefield Systems Group Inc.
* Last revision:				04/27/2007
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	AutoSize:					.T.
*	BackStyle:					0 (Transparent)
*	FontName:					Tahoma
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T. Change FontName to
*								Segoe UI in Vista
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for Label objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sflabel

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RD90LK4PG
[CLASS] line
[BASECLASS] line
[OBJNAME] sfline
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
Name = "sfline"
_memberdata =     1016<VFPData>
builder = 
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
* If we're supposed to bind to the lChanged property of the form, do so.

if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
	pemstatus(Thisform, 'lChanged', 5)
	bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
endif This.lNotifyOnFormChange ...

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFLine
* Based On:						Line
* Purpose:						Base class for all Line objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:				12/15/2005
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	None
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T.
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for Line objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfline

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RD90LIBHI
[CLASS] listbox
[BASECLASS] listbox
[OBJNAME] sflistbox
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="aitems" type="property" display="aItems"/>
<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lrequeryoninit" type="property" display="lRequeryOnInit"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
FontName = "Tahoma"
IntegralHeight = .T.
ItemTips = .T.
Name = "sflistbox"
RowSource = "This.aItems"
RowSourceType = 5
_memberdata =     1499<VFPData>
builder = 
lbindtoformanychange = .F.
lnotifyonformchange = .F.
lrequeryoninit = .T.
lsaveanchor = .F.
lupdatecontrolsource = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
local loParent
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* Call Requery() if we're supposed to; otherwise, initialize aItems to a blank
* string.

	if .lRequeryOnInit
		.Requery()
	else
		.aItems = ''
	endif .lRequeryOnInit

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
* Update the control source in case something binding to our AnyChange event
* looks at it.

with This
	if .lUpdateControlSource
		.UpdateControlSource()
	endif .lUpdateControlSource
endwith

* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE ProgrammaticChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE Requery
* If RowSource is 1-Value but aItems contains values, set RowSource to a comma-
* delimited list of values from aItems. This allows disabled lines using a
* prompt of "\-".

lparameters tlNoAction
local lnI
with This
	if not tlNoAction and .RowSourceType = 1 and ;
		vartype(.aItems[1]) = 'C' and (not empty(.aItems[1]) or ;
		alen(.aItems, 1) > 0)
		.RowSource = ''
		for lnI = 1 to alen(.aItems, 1)
			.RowSource = .RowSource + iif(lnI = 1, '', ',') + .aItems[lnI, 1]
		next lnI
		if empty(.RowSource)
			for lnI = .ListCount to 1 step -1
				.RemoveItem(lnI)
			next lnI
		endif empty(.RowSource)
	endif not tlNoAction ...
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFListBox
* Based On:						ListBox
* Purpose:						Base class for all ListBox objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:				10/09/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	FontName:					Tahoma
*	IntegralHeight:				.T.
*	ItemTips:					.T.
*	RowSource:					This.aItems (see below)
*	RowSourceType:				5 (Array)
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						initialize This.aItems to blanks and call
*								This.Requery if This.lRequeryOnInit is .T. Bind
*								InteractiveChange to the form's AnyChange
*								method and bind OnFormChange to the form's
*								lChanged property if necessary. Change FontName
*								to Segoe UI in Vista
*	InteractiveChange:			calls UpdateControlSource and raises the
*								AnyChange event
*	ProgrammaticChange:			raises the AnyChange event
*	Requery:					handle RowSourceType = 1-Value when This.aItems
*								contains the array of values
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	aItems[1]:					an array that can hold the values used for the
*								ListBox when RowSourceType is 5
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lRequeryOnInit:				.T. to call Requery from Init
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUpdateControlSource:		.T. if UpdateControlSource should be called
*								from InteractiveChange
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the control source
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
* Last revision:	02/27/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatecontrolsource Updates the control source
^aitems[1,0] An array that can hold the values used for the ListBox when RowSourceType is 5
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lrequeryoninit .T. to call Requery from Init
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lupdatecontrolsource .T. if UpdateControlSource should be called from InteractiveChange
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for ListBox objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sflistbox
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCX18AJ24
[CLASS] sfform
[CLASSLOC] sfctrls.vcx
[BASECLASS] form
[OBJNAME] sfmodaldialog
[START PROPERTIES]
DoCreate = .T.
MaxButton = .F.
MinButton = .F.
Name = "sfmodaldialog"
WindowType = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE Activate
* Get around a problem with modal dialogs not always appearing on top of other
* forms by setting AlwaysOnTop temporarily to .T.

local llSave
llSave = This.AlwaysOnTop
This.AlwaysOnTop = .T.
if not llSave
	This.AlwaysOnTop = .F.
endif not llSave

ENDPROC
PROCEDURE Init
* Center the form in _screen or the current screen if reasonable.

local loObject
dodefault()
with This
	if .Desktop and .AutoCenter and (not pemstatus(This, 'oPersist', 5) or ;
		empty(.oPersist.cKey))
		do case
			case _screen.Visible
				loObject = _screen
			case type('_screen.ActiveForm.Name') = 'C'
				loObject = _screen.ActiveForm
		endcase
		if vartype(loObject) = 'O'
			.Top  = max(loObject.Top  + (loObject.Height - .Height)/2, 0)
			.Left = loObject.Left + (loObject.Width  - .Width)/2
		endif vartype(loObject) = 'O'
	endif .Desktop ...
endwith

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFModalDialog
* Based On:						SFForm
* Purpose:						The base class for modal dialogs
* Author:						Doug Hennig
* Copyright:					(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:				06/23/2010
* Include file:					none
*
* Changes in "Based On" class properties:
*	MaxButton:					.F.
*	MinButton:					.F.
*	WindowType:					1 (Modal)
*
* Changes in "Based On" class methods:
*	Activate:					set AlwaysOnTop temporarily .T. to avoid issues
*								with modal form behind other windows
*	Init:						center the form in _screen or current form if
*								reasonable
*
* Custom public properties added:
*	None
*
* Custom protected properties added:
*	None
*
* Custom public methods added:
*	None
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for modal dialogs[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfmodaldialog
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _REF0Y62C2
[CLASS] sfmodaldialog
[CLASSLOC] sfctrls.vcx
[BASECLASS] form
[OBJNAME] sfmodaldialognotitle
[START PROPERTIES]
DoCreate = .T.
Name = "sfmodaldialognotitle"
TitleBar = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE about
*==============================================================================
* Class:						SFModalDialogNoTitle
* Based On:						SFModalDialog
* Purpose:						Modal dialog with no title bar
* Author:						Doug Hennig
* Copyright:					(c) 1996-1998 Stonefield Systems Group Inc.
* Last revision:				12/04/98
* Include file:					none
*
* Changes in "Based On" class properties:
*	TitleBar:					0 - off
*
* Changes in "Based On" class methods:
*	None
*
* Custom public properties added:
*	None
*
* Custom protected properties added:
*	None
*
* Custom public methods added:
*	None
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
A modal dialog with no border and title[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfmodaldialognotitle
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 23, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0VB0L9Y44
[CLASS] optionbutton
[BASECLASS] optionbutton
[OBJNAME] sfoptionbutton
[START PROPERTIES]
</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="oexception" type="property" display="oException"/>
AutoSize = .T.
BackStyle = 0
Caption = "Option1"
FontName = "Tahoma"
Height = 16
Name = "sfoptionbutton"
Width = 63
_memberdata =      146<VFPData>
oexception = .NULL.
[END PROPERTIES]
[START METHODS]
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...
endwith

ENDPROC
PROCEDURE KeyPress
* Prevent Ctrl-0 from inserting a null value.

lparameters tnKeyCode, ;
	tnShiftAltCtrl
if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
	nodefault
endif tnKeyCode = asc('0') ...

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFOptionButton
* Based On:						OptionButton
* Purpose:						Base class for all OptionButton objects
* Author:						Doug Hennig
* Copyright:					(c) 2004-2007 Stonefield Systems Group Inc.
* Last revision:				04/27/2007
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	BackStyle:					0 (Transparent)
*	FontName:					Tahoma
*
* Changes in "Based On" class methods:
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						change the font to Segoe UI in Vista
*	KeyPress:					ignore Ctrl-0
*
* Custom public properties added:
*	oException:					a reference to an Exception object
*
* Custom protected properties added:
*	None
*
* Custom public methods added:
*	About:						provides documentation for the class
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
_memberdata XML Metadata for customizable properties
oexception A reference to an Exception object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfoptionbutton
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCX1912QB
[CLASS] optiongroup
[BASECLASS] optiongroup
[OBJNAME] sfoptiongroup
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
<memberdata name="validation" type="method" display="Validation" favorites="True"/>
BackStyle = 0
ButtonCount = 2
Height = 46
MemberClass = "sfoptionbutton"
MemberClassLibrary = sfctrls.vcx
Name = "sfoptiongroup"
Sfoptionbutton1.Left = 5
Sfoptionbutton1.Name = "Sfoptionbutton1"
Sfoptionbutton1.Top = 5
Sfoptionbutton2.Left = 5
Sfoptionbutton2.Name = "Sfoptionbutton2"
Sfoptionbutton2.Top = 24
Width = 71
_memberdata =     1628<VFPData>
builder = 
lbindtoformanychange = .F.
lnotifyonformchange = .F.
lsaveanchor = .F.
lskipvalidonformclose = .T.
lupdatecontrolsource = .T.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
* Update the control source in case something binding to our AnyChange event
* looks at it.

if This.lUpdateControlSource
	This.UpdateControlSource()
endif This.lUpdateControlSource

* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE ProgrammaticChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE Valid
*==============================================================================
* Method:			Valid
* Status:			Public
* Purpose:			Validate the Value
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	08/20/2002
* Parameters:		none
* Returns:			.T. if the validation succeeded or we're not doing the
*						validation
* Environment in:	none
* Environment out:	none
*==============================================================================

* If the Valid method is fired because the user clicked on a button with the
* Cancel property set to .T. or if the button has an lCancel property (which
* is part of the SFCommandButton base class) and it's .T., or if we're closing
* the form, don't bother doing the rest of the validation.

local loObject
loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
	(This.lSkipValidOnFormClose and ;
	type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
	return .T.
endif (type('loObject.lCancel') = 'L' ...

* If the user tries to leave this control but a field validation rule failed,
* we'll prevent them from doing so.

if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
	Thisform.lFieldRuleFailed = .F.
	return 0
endif type('Thisform.lFieldRuleFailed') = 'L' ...

* Do the custom validation (this allows the developer to put custom validation
* code into the Validation method rather than having to use code like the
* following in the Valid method:
*
* dodefault()
* custom code here
* nodefault

return This.Validation()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFOptionGroup
* Based On:						OptionGroup
* Purpose:						Base class for all OptionGroup objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:				10/09/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	BackStyle:					0 (Transparent)
*	MemberClass:				SFOptionButton
*	MemberClassLibrary:			SFCtrls.VCX
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind InteractiveChange to the form's AnyChange
*								method and bind OnFormChange to the form's
*								lChanged property if necessary
*	InteractiveChange:			raises the AnyChange event
*	ProgrammaticChange:			raises the AnyChange event
*	RightClick:					calls This.ShowMenu
*	Valid:						prevent validation code from executing if the
*								user is cancelling, retain focus if a field
*								rule failed, and call the custom Validation
*								method
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
*								the form is closed
*	lUpdateControlSource:		.T. if UpdateControlSource should be called
*								from InteractiveChange
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	Enabled_Access:				sets the Enabled property of the object and all
*								member objects to the specified value so all
*								objects appear to be enabled or disabled
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the ControlSource with the new value
*	Validation:					abstract method for custom validation code
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE enabled_assign
* Enable or disable member objects.

lparameters tlEnabled
This.SetAll('Enabled', tlEnabled)
This.Enabled = tlEnabled

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
* Last revision:	02/27/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*enabled_assign Sets the Enabled property of the object and all member objects to the specified value so all objects appear to be enabled or disabled
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatecontrolsource Updates the ControlSource with the new value
*validation Abstract method for custom validation code
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lskipvalidonformclose .T. if we can skip validating this control when the form is closed
lupdatecontrolsource .T. if UpdateControlSource should be called from InteractiveChange
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for OptionGroup objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfoptiongroup
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0VA13GWSN
[CLASS] page
[BASECLASS] page
[OBJNAME] sfpage
[START PROPERTIES]
	<memberdata name="about" type="method" display="About"/>
	<memberdata name="builder" type="property" display="Builder"/>
	<memberdata name="cmemberclass" type="property" display="cMemberClass" favorites="True"/>
	<memberdata name="cmemberlibrary" type="property" display="cMemberLibrary" favorites="True"/>
	<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
	<memberdata name="lsetfocustofirstobject" type="property" display="lSetFocusToFirstObject"/>
	<memberdata name="oexception" type="property" display="oException"/>
	<memberdata name="ohook" type="property" display="oHook"/>
	<memberdata name="omenu" type="property" display="oMenu"/>
	<memberdata name="release" type="method" display="Release"/>
	<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
	<memberdata name="showmenu" type="method" display="ShowMenu"/>

</VFPData>
Caption = "Page1"
FontName = "Tahoma"
Height = 151
Name = "sfpage"
Width = 151
_memberdata =      901<VFPData>
builder = 
cmemberclass = 
cmemberlibrary = 
lsetfocustofirstobject = .T.
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START METHODS]
PROCEDURE Activate
local llLockScreen, ;
	llSave
with This

* Lock the screen for snappier refreshes.

	llLockScreen = Thisform.LockScreen
	if not llLockScreen
		Thisform.LockScreen = .T.
	endif not llLockScreen

* If we're supposed to instantiate a member object and haven't yet done so, do
* that now.

	if not empty(.cMemberClass) and type('.oMember.Name') <> 'C'
		if '\' + upper(.cMemberLibrary) $ set('CLASSLIB')
		 	.AddObject('oMember', .cMemberClass)
		else
		 	.NewObject('oMember', .cMemberClass, .cMemberLibrary)
		endif '\' ...
		llSave = pemstatus(.oMember, 'lSaveAnchor', 5)
		with .oMember
			if llSave
				.lSaveAnchor = .T.
			endif llSave
			.Top     = 10
			.Left    = 10
			.Width   = .Width  + This.Parent.Width  - ;
				Thisform.nInitialWidth
			.Height  = .Height + This.Parent.Height - ;
				Thisform.nInitialHeight
			.Visible = .T.
			if llSave
				.lSaveAnchor = .F.
			endif llSave
			.ZOrder(1)
		endwith
	endif not empty(.cMemberClass) ...

* Refresh all controls.

	.Refresh()

* Call Thisform.SetFocusToFirstObject to set focus to the first control on the
* page if we're supposed to. We may not always want that behavior: the user may
* select a page to merely view its content while leaving focus on another
* object that's not in the pageframe. Also, don't do this if the mouse button
* isn't down; in that case, we were activated from the keyboard.

	if .lSetFocusToFirstObject and mdown()
		Thisform.SetFocusToFirstObject(This)
	endif .lSetFocusToFirstObject ...

* Restore the LockScreen setting.

	if not llLockScreen
		Thisform.LockScreen = .F.
	endif not llLockScreen
endwith

ENDPROC
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFPage
* Based On:						Page
* Purpose:						Base class for all Page objects
* Author:						Doug Hennig
* Copyright:					(c) 2003-2008 Stonefield Systems Group Inc.
* Last revision:				03/03/2008
* Include file:					SFCTRLS.H
*
* Changes in "Based On" class properties:
*	FontName:					Tahoma
*
* Changes in "Based On" class methods:
*	Activate:					refresh the controls on the page and
*								instantiate a member object
*	Destroy:					nuke member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						change FontName to Segoe UI in Vista
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	cMemberClass:				the class for a delayed instantiation member
*	cMemberLibrary:				the library containing the class specified in
*								cMemberClass
*	lSetFocusToFirstObject:		.T. to set focus to the first object on the
*								page when the page is activated
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	None
*
* Custom public methods added:
*	About:						provides documentation for the class
*	Release:					releases the object
*	Enabled_Assign:				sets the Enabled property of all member objects
*								to the specified value so they appear to be
*								enabled or disabled
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE enabled_assign
* If the page is enabled or disabled, do the same for every control on the page
* so they appear enabled or disabled.

lparameters tlEnabled
with This
	.SetAll('Enabled', tlEnabled)
	.Enabled = tlEnabled
endwith

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
* Last revision:	01/25/2003
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items may have been added to the menu (abstract
*						in this class)
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .Parent.lUseFormShortcutMenu and ;
				type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .Parent.lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*enabled_assign Sets the Enabled property of all member objects to the specified value so they appear to be enabled or disabled
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
cmemberclass The class for a delayed instantiation member
cmemberlibrary The library containing the class specified in cMemberClass
lsetfocustofirstobject .T. to set focus to the first object on the page when the page is activated
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfpage

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCS0X9KUK
[CLASS] pageframe
[BASECLASS] pageframe
[OBJNAME] sfpageframe
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="getactivepagenumber" type="method" display="GetActivePageNumber"/>
<memberdata name="getpagenumber" type="method" display="GetPageNumber"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="setenabled" type="method" display="SetEnabled"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
ActivePage = 1
Anchor = 15
ErasePage = .T.
Height = 250
MemberClass = "sfpage"
MemberClassLibrary = sfctrls.vcx
Name = "sfpageframe"
PageCount = 1
TabStyle = 1
_memberdata =     1258<VFPData>
builder = 
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
sfpage1.Name = "sfpage1"
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
* If we're supposed to bind to the lChanged property of the form, do so.

if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
	pemstatus(Thisform, 'lChanged', 5)
	bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
endif This.lNotifyOnFormChange ...

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFPageFrame
* Based On:						PageFrame
* Purpose:						Base class for all PageFrame objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:				01/08/2010
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	Anchor:						15 (resize height and width)
*	PageCount:					1
*	MemberClass:				SFPage
*	MemberClassLibrary:			SFCtrls.VCX
*	TabStyle:					1 (Non-justified)
*
* Changes in "Based On" class methods:
*	Destroy:					nuke member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T.
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	GetActivePageNumber:		gets the page number in the Pages collection
*								that matches the current page order
*	GetPageNumber:				gets the page number in the Pages collection
*								that matches the specified page order
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	SetEnabled:					sets the Enabled property of the specified page
*								and all member objects to the specified value
*								so all objects appear to be enabled or disabled
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE getactivepagenumber
return This.GetPageNumber(This.ActivePage)

ENDPROC
PROCEDURE getpagenumber
* Gets the page number in the Pages collection that matches the specified page
* order. These values won't be the same if the PageOrder property for any page
* has been changed.

lparameters tnActivePage
local lnPage, ;
	lnI
with This
	lnPage = 0
	for lnI = 1 to .PageCount
		if .Pages[lnI].PageOrder = tnActivePage
			lnPage = lnI
			exit
		endif .Pages[lnI].PageOrder = tnActivePage
	next lnI
endwith
return lnPage

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE setenabled
* If a page is enabled or disabled, so the same for every control on the page
* so they appear disabled.

lparameters tnPage, ;
	tlEnabled
with This.Pages[tnPage]
	if This.ActivePage = tnPage
		.SetAll('Enabled', tlEnabled)
	endif This.ActivePage = tnPage
	.Enabled = tlEnabled
endwith

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*getactivepagenumber Gets the page number in the Pages collection that matches the current page order
*getpagenumber Gets the page number in the Pages collection that matches the specified page order
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*setenabled Sets the Enabled property of the specified page and all member objects to the specified value so all objects appear to be enabled or disabled
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for PageFrame objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfpageframe

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RD90LKQSI
[CLASS] separator
[BASECLASS] separator
[OBJNAME] sfseparator
[START PROPERTIES]
Height = 0
Name = "sfseparator"
Style = 1
Width = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE about
*==============================================================================
* Class:						SFSeparator
* Based On:						Separator
* Purpose:						The base class for all Separator objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2003 Stonefield Systems Group Inc.
* Last revision:				01/26/2003
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	Style:						1-Vertical Rule
*
* Changes in "Based On" class methods:
*	None
*
* Custom public properties added:
*	None
*
* Custom protected properties added:
*	None
*
* Custom public methods added:
*	About:						provides documentation for the class
*	Release:					releases the object
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*release Releases the object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for Separator objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfseparator

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCT12P3PJ
[CLASS] shape
[BASECLASS] shape
[OBJNAME] sfshape
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
BackStyle = 0
Name = "sfshape"
SpecialEffect = 0
_memberdata =     1033<VFPData>
builder = 
lnotifyonformchange = .F.
lsaveanchor = .F.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
nsavedanchor
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Init
* If we're supposed to bind to the lChanged property of the form, do so.

if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
	pemstatus(Thisform, 'lChanged', 5)
	bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
endif This.lNotifyOnFormChange ...

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFShape
* Based On:						Shape
* Purpose:						The base class for all Shape objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:				12/15/2005
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	BackStyle:					0 - Transparent
*	SpecialEffect:				0 - 3D
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	Init:						bind OnFormChange to Thisform.lChanged if
*								lNotifyOnFormChange is .T.
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	None
*==============================================================================

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for all Shape objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfshape

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCY0ZANFW
[CLASS] spinner
[BASECLASS] spinner
[OBJNAME] sfspinner
[START PROPERTIES]
	<memberdata name="about" type="method" display="About"/>
	<memberdata name="adjustselstart" type="method" display="AdjustSelStart"/>
	<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
	<memberdata name="builder" type="property" display="Builder"/>
	<memberdata name="cinputmask" type="property" display="cInputMask"/>
	<memberdata name="csign" type="property" display="cSign"/>
	<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
	<memberdata name="lcalculator" type="property" display="lCalculator" favorites="True"/>
	<memberdata name="lhasdecimal" type="property" display="lHasDecimal"/>
	<memberdata name="lhasinteger" type="property" display="lHasInteger"/>
	<memberdata name="lindecimalpart" type="property" display="lInDecimalPart"/>
	<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
	<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
	<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
	<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
	<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/></VFPData>
	<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
	<memberdata name="nhighvalue" type="property" display="nHighValue" favorites="True"/>
	<memberdata name="nhighvalue_assign" type="method" display="nHighValue_Assign"/>
	<memberdata name="nlowvalue" type="property" display="nLowValue" favorites="True"/>
	<memberdata name="nlowvalue_assign" type="method" display="nLowValue_Assign"/>
	<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
	<memberdata name="nselstart" type="property" display="nSelStart"/>
	<memberdata name="oexception" type="property" display="oException"/>
	<memberdata name="ohook" type="property" display="oHook"/>
	<memberdata name="omenu" type="property" display="oMenu"/>
	<memberdata name="onformchange" type="method" display="OnFormChange"/>
	<memberdata name="release" type="method" display="Release"/>
	<memberdata name="setcalcvalues" type="method" display="SetCalcValues"/>
	<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
	<memberdata name="showmenu" type="method" display="ShowMenu"/>
	<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
	<memberdata name="validation" type="method" display="Validation" favorites="True"/>

FontName = "Tahoma"
Name = "sfspinner"
SelectOnEntry = .T.
_memberdata =     2616<VFPData>
builder = 
cinputmask = 
csign = 
lbindtoformanychange = .F.
lcalculator = .T.
lhasdecimal = .F.
lhasinteger = .T.
lindecimalpart = .F.
lnotifyonformchange = .F.
lsaveanchor = .F.
lskipvalidonformclose = .T.
lupdatecontrolsource = .T.
luseformshortcutmenu = .F.
nhighvalue = 999999999
nlowvalue = -99999999
nsavedanchor = 0
nselstart = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
adjustselstart
cinputmask
csign
lhasdecimal
lhasinteger
lindecimalpart
nsavedanchor
nselstart
[END PROTECTED]
[START METHODS]
PROCEDURE Click
* If we're acting like a calculator, make any necessary adjustments to
* SelStart.

with This
	if .lCalculator
		.AdjustSelStart(0)
	endif .lCalculator
endwith

ENDPROC
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE GotFocus
with This

* If we're acting like a calculator, adjust SelStart to be in the integer part.

	if .lCalculator
		if .lHasDecimal
			.AdjustSelStart(at('.', .InputMask) - .SelStart)
		else
			.AdjustSelStart(len(.InputMask) - .SelStart)
		endif .lHasDecimal
		.lInDecimalPart = not .lHasInteger
	endif .lCalculator
endwith

ENDPROC
PROCEDURE Init
local loParent
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* Initialize "calculator" properties.

	.SetCalcValues()

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
with This

* If we're acting like a calculator, set SelStart to its saved value and then
* make any necessary adjustments.

	if .lCalculator
		.SelStart = .nSelStart
		.AdjustSelStart(0)
	endif .lCalculator

* Update the control source in case something binding to our AnyChange event
* looks at it.

	if .lUpdateControlSource
		.UpdateControlSource()
	endif .lUpdateControlSource

* Call a common method for handling changes.

	raiseevent(This, 'AnyChange')
endwith

ENDPROC
PROCEDURE KeyPress
lparameters tnKeyCode, ;
	tnShiftAltCtrl
local lnSelEnd, ;
	lcString, ;
	lnPos, ;
	llIntPart, ;
	lnLen, ;
	lnI, ;
	lcChar, ;
	lnAddSelStart, ;
	lnValue, ;
	llIntFull, ;
	lnDecPos, ;
	llChanged, ;
	llOtherWise, ;
	llNoDefault

* Prevent Ctrl-0 from inserting a null value.

if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
	nodefault
	return
endif tnKeyCode = asc('0') ...
with This
	if .lCalculator

* If some characters are selected and the user entered a digit or hit Del,
* replace the selected characters with the input key.

		if .SelLength > 0 and (between(tnKeyCode, 48, 57) or ;
			tnKeyCode = 7) and tnShiftAltCtrl = 0
			lnSelEnd  = .SelStart + .SelLength
			lcString  = .Text
			lnPos     = 1
			llIntPart = .T.
			lnLen     = len(.InputMask)
   
* Remove the selected characters from the value.

			for lnI = 1 to lnLen
				lcChar = substr(.InputMask, lnI, 1)
				do case
					case not inlist(lcChar, '.', '-', ' ') and ;
						not isdigit(lcChar)
						lcString = stuff(lcString, lnPos, 1, '')
					case lcChar = '.'
						llIntPart = .F.
						lnPos     = lnPos + 1
					case not between(lnI, .SelStart + 1, lnSelEnd)
						lnPos = lnPos + 1
					case llIntPart
						lcString = stuff(lcString, lnPos, 1, '')
					otherwise
						lcString = stuff(lcString, lnPos, 1, '0')
						lnPos    = lnPos + 1
				endcase
			next lnI

* Recalculate the SelStart position.

			lnAddSelStart = 0
			lnPos         = at('.', .InputMask)
			do case
				case lnPos = 0
					lnAddSelStart = .SelLength
				case between(lnPos, .SelStart + 1, lnSelEnd)
					lnAddSelStart = lnPos - .SelStart
				case lnPos > lnSelEnd
					lnAddSelStart = .SelLength
			endcase

* Save the new value and adjust the cursor position.

			lnPos     = .SelStart
			.Value    = val(lcString)
			.SelStart = lnPos
			.AdjustSelStart(lnAddSelStart - (.SelStart - lnPos))

* If the user hit Del, we're done.

			if tnKeyCode = 7
				nodefault
				.InteractiveChange()
				return
			endif tnKeyCode = 7
		endif .SelLength > 0 ...

* Save the sign if the value is non-zero.

		do case
			case .Value = 0
			case .Value > 0
				.cSign = ''
			otherwise
				.cSign = '-'
		endcase

* Save the value, then remove non-digit characters, and substitute the cursor
* position with CHR(1).

		lnValue  = .Value
		lcString = stuff(.Text, .SelStart + 1, 0, chr(1))
		lnPos    = 1
		do while lnPos <= len(lcString)
			lcChar = substr(lcString, lnPos, 1)
			if not inlist(lcChar, '.', '-', ' ', chr(1)) and ;
				not isdigit(lcChar)
				lcString = stuff(lcString, lnPos, 1, '')
			else
				lnPos = lnPos + 1
			endif not inlist(lcChar ...
		enddo while lnPos <= len(lcString)

* See if the integer part is full.

		llIntFull = len(lcString) = len(ltrim(lcString))
		lcString  = alltrim(lcString)

* Find the cursor position and remove it, then save the decimal position.

		lnPos    = at(chr(1), lcString) - 1
		lcString = strtran(lcString, chr(1))
		lnDecPos = at('.', lcString)

* See if the cursor is in the decimal or integer position.

		do case
			case not .lHasDecimal
				.lInDecimalPart = .F.
			case lnPos > lnDecPos or (lnPos = lnDecPos and llIntFull)
				.lInDecimalPart = .T.
			case lnPos < lnDecPos and .lHasInteger
				.lInDecimalPart = .F.
		endcase

* Process things depending on what key the user hit.

		lnAddSelStart = 0
		llChanged     = .F.
		llOtherwise   = .F.
		lnValue       = val(lcString)
		do case

* "0" to "9": enter the digit.

			case between(tnKeyCode, 48, 57) and tnShiftAltCtrl = 0
				nodefault
				llNoDefault = .T.
				do case

* If we're in the integer part and it isn't full, insert the character in the
* integer part.

					case not .lInDecimalPart and not llIntFull
						if lnPos = lnDecPos
							lnPos = lnPos - 1
						endif lnPos = lnDecPos
						lcString  = stuff(lcString, lnPos + 1, 0, ;
							chr(tnKeyCode))
						lnValue   = val(lcString)
						llChanged = .T.

* We're not at the end of the decimal area yet, so overwrite it.

		         	case .SelStart < len(.InputMask)
						lcString      = stuff(lcString, lnPos + 1, 1, ;
							chr(tnKeyCode))
						lnAddSelStart = 1
						lnValue       = val(lcString)
						llChanged     = .T.
				endcase

* Backspace: remove the digit to the left if there is one.

			case tnKeyCode = 127
				nodefault
				llNoDefault = .T.
				if lnPos > 0

* If we have an integer part and we're at the decimal point, move to the left
* to put the cursor in a valid position.

					if .lHasInteger and substr(lcString, lnPos, 1) = '.'
						lnPos = lnPos - 1
						.lInDecimalPart = .F.
					endif .lHasInteger ...

* If there is a digit on the left, remove it.

					if lnPos > 0 and ;
						not inlist(substr(lcString, lnPos, 1), '-', '.')
						lcString = stuff(lcString, lnPos, 1, '')

* If we're at the decimal part, move the cursor to the left.

						if .lInDecimalPart
							lnAddSelStart = -1
						endif .lInDecimalPart
						lnValue   = val(lcString)
						llChanged = .T.
					endif lnPos > 0 ...
				endif lnPos > 0

* Del: remove the digit to the right if there is one.

			case tnKeyCode = 7
				nodefault
				llNoDefault = .T.
				if lnPos < len(lcString) and substr(lcString, lnPos, 1) <> '-'

* If we're at the decimal point and have a decimal part, put the cursor at it.

					if .lHasDecimal and substr(lcString, lnPos, 1) = '.'
						.lInDecimalPart = .T.
					endif .lHasDecimal ...

* Remove the character after the cursor. If it's at the integer part, move to
* the right.

					lcString = stuff(lcString, lnPos + 1, 1, '')
					if not .lInDecimalPart
						lnAddSelStart = 1
					endif not .lInDecimalPart
					lnValue   = val(lcString)
					llChanged = .T.
				endif lnPos < len(lcString) ...

* "C": set the value to zero.

			case inlist(tnKeyCode, 67, 99) and inlist(tnShiftAltCtrl, 0, 1)
				nodefault
				llNoDefault = .T.
				.cSign      = ''
				lnValue     = 0.0000
				llChanged   = .T.
				if .lHasDecimal
					lnAddSelStart = at('.', .InputMask) - .SelStart
				else
					lnAddSelStart = len(.InputMask) - .SelStart
				endif .lHasDecimal
				.lInDecimalPart = not .lHasInteger

* +: change to positive.

			case tnKeyCode = 43 and inlist(tnShiftAltCtrl, 0, 1)
				nodefault
				llNoDefault = .T.
				if .SpinnerHighValue < 0
					.cSign = '-'
					if lnValue > 0
						lnValue   = -lnValue
						llChanged = .T.
					endif lnValue > 0
				else
					.cSign = ''
					if lnValue < 0
						lnValue   = -lnValue
						llChanged = .T.
					endif lnValue < 0
				endif .SpinnerHighValue < 0

* -: change to negative.

			case tnKeyCode = 45 and inlist(tnShiftAltCtrl, 0, 1)
				nodefault
				llNoDefault = .T.
				.cSign      = iif(.cSign = '-', '', '-')
				do case
					case .SpinnerLowValue < 0
						lnValue   = -lnValue
						llChanged = .T.
					case .cSign = '-'
			            .cSign = ''
				endcase

* Decimal: change to decimal input.

			case tnKeyCode = asc('.') and inlist(tnShiftAltCtrl, 0, 1)
				nodefault
				llNoDefault = .T.
				if .lHasDecimal
					.lInDecimalPart = .T.
					lnAddSelStart = at('.', .InputMask) - .SelStart
					llChanged     = .T.
				endif .lHasDecimal

* Home: move the cursor to the beginning.

			case tnKeyCode = 1
				nodefault
				.lInDecimalPart = not .lHasInteger
				lnAddSelStart   = -.SelStart
				llChanged       = .T.

* End: move the cursor to the end.

			case tnKeyCode = 6
				nodefault
				.lInDecimalPart = .lHasDecimal
				lnAddSelStart   = len(.InputMask) - .SelStart + 1
				llChanged       = .T.

* Left arrow: move the cursor to the left.

			case tnKeyCode = 19
				nodefault
				lnAddSelStart = -1
				llChanged     = .T.

* Right arrow: move the cursor to the right.

			case tnKeyCode = 4
				nodefault
				lnAddSelStart = 1
				llChanged     = .T.

* Ctrl-UpArrow: set the maximum value.

			case tnKeyCode = 141 and tnShiftAltCtrl = 2
				nodefault
				llNoDefault = .T.
				lnValue     = val(transform(.SpinnerHighValue, .cInputMask))
				.cSign      = iif(lnValue > 0, '', '-')
				llChanged   = .T.

* Ctrl-DownArrow: set the minimum value.

			case tnKeyCode = 145 and tnShiftAltCtrl = 2
				nodefault
				llNoDefault = .T.
				lnValue     = val(transform(.SpinnerLowValue, .cInputMask))
				.cSign      = iif(lnValue > 0, '', '-')
				llChanged   = .T.

* Don't do anything.

			otherwise
				llOtherwise = .T.
		endcase

* If the value was changed, update the spinner's value and cursor position.

		if not llOtherwise and llChanged
			if (.cSign == '-' and lnValue > 0) or (.cSign == ''  and ;
				lnValue < 0)
				lnValue = -lnValue
			endif (.cSign == '-' ...
			lnPos     = .SelStart
			.Value    = lnValue
			.SelStart = lnPos
			.AdjustSelStart(lnAddSelStart)
		endif not llOtherwise ...

* If we used a NODEFAULT and changed the value, fire InteractiveChange.

		if llNoDefault
			.InteractiveChange()
		endif llNoDefault
	endif .lCalculator
endwith

ENDPROC
PROCEDURE ProgrammaticChange
with This

* If we're acting like a calculator, set SelStart to its saved value and then
* make any necessary adjustments.

	if .lCalculator
		.SelStart = .nSelStart
		.AdjustSelStart(0)
	endif .lCalculator

* Call a common method for handling changes.

	raiseevent(This, 'AnyChange')
endwith

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE Valid
*==============================================================================
* Method:			Valid
* Status:			Public
* Purpose:			Validate the Value
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	08/20/2002
* Parameters:		none
* Returns:			.T. if the validation succeeded or we're not doing the
*						validation
* Environment in:	none
* Environment out:	none
*==============================================================================

* If the Valid method is fired because the user clicked on a button with the
* Cancel property set to .T. or if the button has an lCancel property (which
* is part of the SFCommandButton base class) and it's .T., or if we're closing
* the form, don't bother doing the rest of the validation.

local loObject
loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
	(This.lSkipValidOnFormClose and ;
	type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
	return .T.
endif (type('loObject.lCancel') = 'L' ...

* If the user tries to leave this control but a field validation rule failed,
* we'll prevent them from doing so.

if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
	Thisform.lFieldRuleFailed = .F.
	return 0
endif type('Thisform.lFieldRuleFailed') = 'L' ...

* Don't allow a value outside the valid range.

if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
	return 0
endif not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)

* Do the custom validation (this allows the developer to put custom validation
* code into the Validation method rather than having to use code like the
* following in the Valid method:
*
* dodefault()
* custom code here
* nodefault

return This.Validation()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFSpinner
* Based On:						Spinner
* Purpose:						The base class for all Spinner objects
* Author:						Doug Hennig. "Calculator-style" entry based on
*								code by Marcelo Ris published in FoxPro
*								Advisor, June 1999
* Copyright:					(c) 1996-2010 Stonefield Systems Group Inc.
* Last revision:				04/08/2010
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	FontName:					Tahoma
*	SelectOnEntry:				.T.
*
* Changes in "Based On" class methods:
*	Click:						if we're acting like a calculator, make any
*								necessary adjustments to SelStart
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	GotFocus:					if we're acting like a calculator, adjust
*								SelStart to be in the integer part
*	Init:						initialize "calculator" values. Bind
*								InteractiveChange to the form's AnyChange
*								method and bind OnFormChange to the form's
*								lChanged property if necessary. Change FontName
*								to Segoe UI in Vista
*	InteractiveChange:			set SelStart to its saved value and make any
*								necessary adjustments, then raise the AnyChange
*								event
*	KeyPress:					handle calculator-style entry
*	ProgrammaticChange:			set SelStart to its saved value and make any
*								necessary adjustments, then raise the AnyChange
*								event
*	RightClick:					calls This.ShowMenu
*	Valid:						prevent validation code from executing if the
*								user is cancelling, retain focus if a field
*								rule failed, and call the custom Validation
*								method
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lCalculator:				.T. to use calculator-style digit entry
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
*								the form is closed
*	lUpdateControlSource:		.T. if UpdateControlSource should be called
*								from InteractiveChange
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	nHighValue:					the maximum value (Assign calls SetCalcValues)
*	nLowValue:					the minimum value (Assign calls SetCalcValues)
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	cInputMask:					the saved InputMask
*	cSign:						the saved sign of the value
*	lHasDecimal:				.T. if the value has a decimal part
*	lHasInteger:				.T. if the value has an integer part
*	lInDecimalPart:				.T. if the cursor is in the decimal part of the
*								value
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*	nSelStart:					the saved value of SelStart
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	SetCalcValues:				handles changes to any of the "calculator"
*								properties
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the ControlSource with the new value
*	Validation:					abstract method for custom validation code
*
* Custom protected methods added:
*	AdjustSelStart:				adjust SelStart as necessary
*==============================================================================

ENDPROC
PROCEDURE adjustselstart
lparameters tnMove
local lnLen, ;
	lcText1, ;
	lcText2, ;
	lnMin, ;
	lnSelStart, ;
	lnMove, ;
	lnSelLength, ;
	lnPos, ;
	lnChar
with This

* Calculate the minimum position for the cursor by removing any non-digit
* characters from the InputMask.

	lnLen   = len(.InputMask)
	lcText1 = .Text
	lcText2 = ltrim(lcText1)
	do while not empty(lcText2) and not isdigit(left(lcText2, 1))
		lcText2 = ltrim(right(lcText2, len(lcText2) - 1))
	enddo while not empty(lcText2) ...
	lnMin = len(lcText1) - len(lcText2)

* Calculate the the new cursor position, keeping it between the maximum and
* minimum values.

	lnSelStart = .SelStart + tnMove
	do case
		case lnSelStart < lnMin
			lnSelStart = lnMin
			lnMove     = 0
		case lnSelStart > lnLen
			lnSelStart = lnLen
			lnMove     = 0
		otherwise
			lnMove = tnMove
	endcase

* Depending on whether we're moving positive or negative, move the cursor right
* or left every time there is a non-digit on the left.

	if lnMove >= 0
		do while lnSelStart < lnLen and ;
			substr(.InputMask, lnSelStart + 1, 1) <> '9'
			lnSelStart = lnSelStart + 1
		enddo while lnSelStart < lnLen ...
	else
		do while lnSelStart > lnMin and ;
			substr(.InputMask, lnSelStart + 1, 1) <> '9'
			lnSelStart = lnSelStart - 1
		enddo while lnSelStart > lnMin ...
	endif lnMove >= 0

* Adjust SelLength as necessary, then adjust SelStart to the new position.

	lnSelLength = .SelLength
	if lnSelLength > 0
		lnSelLength = max(lnSelLength - (lnSelStart - .SelStart), 0)
	endif lnSelLength > 0
	.SelStart  = lnSelStart
	.nSelStart = lnSelStart
	.SelLength = lnSelLength

* Set the spinner's increment to the value (integer or decimal) corresponding
* to the left position of the cursor.

	lnPos   = lnSelStart + 1
	lnChar  = 1
	lcText1 = .InputMask
	do while lnChar <= len(lcText1) 
		lcText2 = substr(lcText1, lnChar, 1)
		do case
			case lcText2 = '.'
				if lnChar <= lnSelStart
					lnPos = lnPos - 1
				endif lnChar <= lnSelStart
				lnChar = lnChar + 1
	      	case not isdigit(lcText2)
				if lnChar <= lnSelStart
					lnPos = lnPos - 1
				endif lnChar <= lnSelStart
				lcText1    = stuff(lcText1, lnChar, 1, '')
				lnSelStart = lnSelStart - 1
			otherwise
				lnChar = lnChar + 1
		endcase
	enddo while lnChar <= len(lcText1) 
	.Increment = val(strtran(stuff(lcText1, lnPos, 0, '1'), '9', '0'))
endwith

ENDPROC
PROCEDURE anychange
* Abstract method

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE nhighvalue_assign
lparameters tnValue
This.nHighValue = tnValue
This.InputMask  = ''
This.SetCalcValues()

ENDPROC
PROCEDURE nlowvalue_assign
lparameters tnValue
This.nLowValue = tnValue
This.SetCalcValues()

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE setcalcvalues
local lcValue, ;
	lnPos, ;
	lcMaxMask, ;
	lnLen, ;
	lnI, ;
	lcChar, ;
	lcMinMask, ;
	lnPos, ;
	lnMax, ;
	lnMin
with This

* If the InputMask is empty, initialize it with a default value.

	if empty(.InputMask) and not empty(.nHighValue)
		lcValue   = trim(padr(.nHighValue, 20))
		lnPos     = at('.', lcValue)
	   .InputMask = replicate('9', floor(log10(.nHighValue)) + 1) + ;
		   	iif(lnPos > 0, '.' + replicate('9', len(lcValue) - lnPos), '')
	endif empty(.InputMask) ...

* Find the maximum mask by removing any special characters from InputMask.

	lcMaxMask = ''
	lnLen     = len(.InputMask)
	for lnI = 1 to lnLen
		lcChar = substr(.InputMask, lnI, 1)
		if isdigit(lcChar) or lcChar = '.'
			lcMaxMask = lcMaxMask + lcChar
		endif isdigit(lcChar) or lcChar = '.'
	next lnI

* Save the maximum mask in cInputMask.

	.cInputMask = lcMaxMask

* The minimum mask is obtained by removing the first character of the maximum
* mask so we have one character for the sign.

	lcMinMask = right(lcMaxMask, len(lcMaxMask) - 1)

* Set SpinnerHighValue and SpinnerLowValue to valid values. We won't set the
* Keyboard equivalents because that prevents the user from canceling out of a
* form without entering a valid value; instead, we'll trap that in Valid.

	lnMax = min(val(lcMaxMask),  .nHighValue, 2147483647)
	lnMin = max(-val(lcMinMask), .nLowValue,  -2147483647)
	.SpinnerHighValue = lnMax
	.SpinnerLowValue  = lnMin

* If the values are only a single digit, turn off calculator mode.

	if lnMin >= 0 and lnMax <= 9
		.lCalculator = .F.
	endif lnMin >= 0 and lnMax <= 9

* See if the mask has integer and decimal parts, and save it.

	if .lCalculator
		lnPos = at('.', .InputMask) 
		if lnPos > 0
			.lHasInteger = '9' $ left(.InputMask, lnPos - 1)
			.lHasDecimal = '9' $ substr(.InputMask, lnPos)
		else
			.lHasInteger = '9' $ This.InputMask
			.lHasDecimal = .F.
		endif lnPos > 0
	endif .lCalculator
endwith

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	08/24/2005
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	oLocalizer may contain a reference to a localization object
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject
local lcCut, ;
	lcCopy, ;
	lcPaste, ;
	lcClear, ;
	lcSelect
if type('oLocalizer.Name') = 'C'
	lcCut    = oLocalizer.GetLocalizedString('MENU_CUT')
	lcCopy   = oLocalizer.GetLocalizedString('MENU_COPY')
	lcPaste  = oLocalizer.GetLocalizedString('MENU_PASTE')
	lcClear  = oLocalizer.GetLocalizedString('MENU_CLEAR')
	lcSelect = oLocalizer.GetLocalizedString('MENU_SELECT_ALL')
else
	lcCut    = 'Cu\<t'
	lcCopy   = '\<Copy'
	lcPaste  = '\<Paste'
	lcClear  = 'Cle\<ar'
	lcSelect = 'Se\<lect All'
endif type('oLocalizer.Name') = 'C'
with toMenu
	.AddMenuBar(lcCut,    "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'CutXPSmall.bmp', '_med_cut')
	.AddMenuBar(lcCopy,   "sys(1500, '_MED_COPY',  '_MEDIT')", , , , , , ;
		'CopyXPSmall.bmp', '_med_copy')
	.AddMenuBar(lcPaste,  "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'PasteXPSmall.bmp', '_med_paste')
	.AddMenuBar(lcClear,  "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'_med_clear', '_med_clear')
	.AddMenuSeparator()
	.AddMenuBar(lcSelect, "sys(1500, '_MED_SLCTA', '_MEDIT')", , , , , , ;
		'_med_slcta', '_med_slcta')
endwith

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
* Last revision:	02/27/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
PROCEDURE validation
* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*adjustselstart Adjust SelStart as necessary
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*lsaveanchor_assign 
*nhighvalue_assign 
*nlowvalue_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*setcalcvalues Handles changes to any of the "calculator" properties
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
*updatecontrolsource Updates the ControlSource with the new value
*validation An abstract method for custom validation code
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
cinputmask The saved InputMask
csign The saved sign of the value
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lcalculator .T. to use calculator-style digit entry
lhasdecimal .T. if the value has a decimal part
lhasinteger .T. if the value has an integer part
lindecimalpart .T. if the cursor is in the decimal part of the value
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lskipvalidonformclose .T. if we can skip validating this control when the form is closed
lupdatecontrolsource .T. if UpdateControlSource should be called from InteractiveChange
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nhighvalue The maximum value
nlowvalue The minimum value
nsavedanchor The anchor value saved in lSaveAnchor_Assign
nselstart The saved value of SelStart
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for all Spinner objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfspinner
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCS0T4KK1
[CLASS] textbox
[BASECLASS] textbox
[OBJNAME] sftextbox
[START PROPERTIES]

</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="cballoontiptitle" type="property" display="cBalloonTipTitle"/>
<memberdata name="hideballoontip" type="method" display="HideBalloonTip"/>
<memberdata name="lballoontips" type="property" display="lBalloonTips"/>
<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
<memberdata name="lhaveballoontipcontrol" type="property" display="lHaveBalloonTipControl"/>
<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="onformchange" type="method" display="OnFormChange"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showballoontip" type="method" display="ShowBalloonTip"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
<memberdata name="validation" type="method" display="Validation" favorites="True"/>
FontName = "Tahoma"
IntegralHeight = .T.
Name = "sftextbox"
SelectOnEntry = .T.
_memberdata =     1878<VFPData>
builder = 
cballoontiptitle = 
lballoontips = .F.
lbindtoformanychange = .F.
lhaveballoontipcontrol = .NULL.
lnotifyonformchange = .F.
lsaveanchor = .F.
lskipvalidonformclose = .T.
luseformshortcutmenu = .F.
nsavedanchor = 0
oexception = .NULL.
ohook = .NULL.
omenu = .NULL.
[END PROPERTIES]
[START PROTECTED]
hideballoontip
lhaveballoontipcontrol
nsavedanchor
showballoontip
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Nuke member objects.

This.oHook = .NULL.
This.oMenu = .NULL.

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE GotFocus
This.ShowBalloonTip(.T.)

ENDPROC
PROCEDURE Init
with This

* Change the font to Segoe UI in Vista.

	if os(3) >= '6' and .FontName = 'Tahoma'
		.FontName = 'Segoe UI'
	endif os(3) >= '6' ...

* If we're supposed to bind our AnyChange event to our form's AnyChange method,
* do so.

	if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'AnyChange', 5)
		bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
	endif .lBindToFormAnyChange ...

* If we're supposed to bind to the lChanged property of the form, do so.

	if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
		pemstatus(Thisform, 'lChanged', 5)
		bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
	endif .lNotifyOnFormChange ...
endwith

ENDPROC
PROCEDURE InteractiveChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE KeyPress
* Prevent Ctrl-0 from inserting a null value.

lparameters tnKeyCode, ;
	tnShiftAltCtrl
if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
	nodefault
endif tnKeyCode = asc('0') ...

* Prevent backspace from leaving the control.

if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
   nodefault
endif tnKeyCode = 127 ...

ENDPROC
PROCEDURE LostFocus
This.HideBalloonTip()

ENDPROC
PROCEDURE MouseEnter
lparameters tnButton, ;
	tnShift, ;
	tnXCoord, ;
	tnYCoord
This.ShowBalloonTip()

ENDPROC
PROCEDURE MouseLeave
lparameters tnButton, ;
	tnShift, ;
	tnXCoord, ;
	tnYCoord
This.HideBalloonTip()

ENDPROC
PROCEDURE ProgrammaticChange
* Call a common method for handling changes.

raiseevent(This, 'AnyChange')

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE Valid
*==============================================================================
* Method:			Valid
* Status:			Public
* Purpose:			Validate the Value
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	08/20/2002
* Parameters:		none
* Returns:			.T. if the validation succeeded or we're not doing the
*						validation
* Environment in:	none
* Environment out:	none
*==============================================================================

* If the Valid method is fired because the user clicked on a button with the
* Cancel property set to .T. or if the button has an lCancel property (which
* is part of the SFCommandButton base class) and it's .T., or if we're closing
* the form, don't bother doing the rest of the validation.

local loObject
loObject = sys(1270)
if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
	(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
	(This.lSkipValidOnFormClose and ;
	type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
	return .T.
endif (type('loObject.lCancel') = 'L' ...

* If the user tries to leave this control but a field validation rule failed,
* we'll prevent them from doing so.

if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
	Thisform.lFieldRuleFailed = .F.
	return 0
endif type('Thisform.lFieldRuleFailed') = 'L' ...

* Do the custom validation (this allows the developer to put custom validation
* code into the Validation method rather than having to use code like the
* following in the Valid method:
*
* dodefault()
* custom code here
* nodefault

return This.Validation()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFTextBox
* Based On:						TextBox
* Purpose:						The base class for all TextBox objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
* Last revision:				12/22/2008
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	FontName:					Tahoma
*	IntegralHeight:				.T.
*	SelectOnEntry:				.T.
*
* Changes in "Based On" class methods:
*	Destroy:					nukes member objects
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*	GotFocus:					call This.ShowBalloonTip to show balloon tips
*	Init:						bind AnyChange to the form's AnyChange method
*								and bind OnFormChange to the form's lChanged
*								property if necessary. Change FontName to
*								Segoe UI in Vista.
*	InteractiveChange:			raises the AnyChange event
*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
*								control
*	LostFocus:					call This.HideBalloonTip to hide balloon tips
*	MouseEnter:					call This.ShowBalloonTip to show balloon tips
*	MouseLeave:					call This.HideBalloonTip to hide balloon tips
*	ProgrammaticChange:			raises the AnyChange event
*	RightClick:					call This.ShowMenu
*	Valid:						prevent validation code from executing if the
*								user is cancelling, retain focus if a field
*								rule failed, and call the custom Validation
*								method
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lBalloonTips:				.T. to use balloon tips
*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
*								its form's AnyChange method
*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
*								is bound to the lChanged property of the form
*	lSaveAnchor:				this allows a container to use
*								SetAll('lSaveAnchor') to save/reset and then
*								restore Anchor when the form's size is changed
*								but controls shouldn't move
*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
*								the form is closed
*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
*								included with this object's
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	lHaveBalloonTipControl:		.T. if the form has a balloon tip control
*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AnyChange:					called from the InteractiveChange and
*								ProgrammaticChange events to consolidate
*								change code in one place
*	OnFormChange:				fired when the lChanged property of the form
*								changes if lNotifyOnFormChange is .T.
*	Release:					releases the object
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*	UpdateControlSource:		updates the ControlSource with the new value
*	Validation:					abstract method for custom validation code
*
* Custom protected methods added:
*	HideBalloonTip:				hides a balloon tip for the control
*	ShowBalloonTip:				shows a balloon tip for the control
*==============================================================================

ENDPROC
PROCEDURE anychange
* Abstract method

ENDPROC
PROCEDURE hideballoontip
if This.lBalloonTips and This.lHaveBalloonTipControl
	Thisform.oBalloonTip.ctlShow(0)
endif This.lBalloonTips ...

ENDPROC
PROCEDURE lsaveanchor_assign
lparameters tlSaveAnchor
do case
	case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
	case tlSaveAnchor
		This.nSavedAnchor = This.Anchor
		This.Anchor       = 0
	otherwise
		This.Anchor = This.nSavedAnchor
endcase

ENDPROC
PROCEDURE onformchange
* Refresh the control when something in the form changes.

This.Refresh()

ENDPROC
PROCEDURE release
* Release the object.

release This

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	08/24/2005
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	oLocalizer may contain a reference to a localization object
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject
local lcCut, ;
	lcCopy, ;
	lcPaste, ;
	lcClear, ;
	lcSelect
if type('oLocalizer.Name') = 'C'
	lcCut    = oLocalizer.GetLocalizedString('MENU_CUT')
	lcCopy   = oLocalizer.GetLocalizedString('MENU_COPY')
	lcPaste  = oLocalizer.GetLocalizedString('MENU_PASTE')
	lcClear  = oLocalizer.GetLocalizedString('MENU_CLEAR')
	lcSelect = oLocalizer.GetLocalizedString('MENU_SELECT_ALL')
else
	lcCut    = 'Cu\<t'
	lcCopy   = '\<Copy'
	lcPaste  = '\<Paste'
	lcClear  = 'Cle\<ar'
	lcSelect = 'Se\<lect All'
endif type('oLocalizer.Name') = 'C'
with toMenu
	.AddMenuBar(lcCut,    "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'CutXPSmall.bmp', '_med_cut')
	.AddMenuBar(lcCopy,   "sys(1500, '_MED_COPY',  '_MEDIT')", , , , , , ;
		'CopyXPSmall.bmp', '_med_copy')
	.AddMenuBar(lcPaste,  "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'PasteXPSmall.bmp', '_med_paste')
	.AddMenuBar(lcClear,  "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
		'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
		'_med_clear', '_med_clear')
	.AddMenuSeparator()
	.AddMenuBar(lcSelect, "sys(1500, '_MED_SLCTA', '_MEDIT')", , , , , , ;
		'_med_slcta', '_med_slcta')
endwith

ENDPROC
PROCEDURE showballoontip
lparameters tlGotFocus
#define CON_BTPOS_ACTIVECTRL 	2
#define CON_BTPOS_MOUSE			6
#define TTI_INFO				1

* Set lHaveBalloonTipControl if the form has a balloon tip control.

if vartype(This.lHaveBalloonTipControl) <> 'L'
	This.lHaveBalloonTipControl = pemstatus(Thisform, 'oBalloonTip', 5)
endif vartype(This.lHaveBalloonTipControl) <> 'L'

* If we're supposed to show balloon tips and we have a control, do so.

if This.lBalloonTips and This.lHaveBalloonTipControl
	Thisform.oBalloonTip.ctlShow(iif(tlGotFocus, CON_BTPOS_ACTIVECTRL, ;
		CON_BTPOS_MOUSE), This.ToolTipText, This.cBalloonTipTitle, TTI_INFO)
endif This.lBalloonTips ...

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook, ;
	loForm
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook
	loForm   = Thisform

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...

* If desired, use the form's shortcut menu as well.

			if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
				pemstatus(loForm, 'ShortcutMenu', 5)
				loForm.ShortcutMenu(.oMenu, 'loForm')
			endif .lUseFormShortcutMenu ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
PROCEDURE updatecontrolsource
*==============================================================================
* Method:			UpdateControlSource
* Status:			Public
* Purpose:			Updates the ControlSource with the new value
* Author:			Doug Hennig
* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
* Last revision:	02/27/2006
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the ControlSource may have been updated
*==============================================================================

local lnPos, ;
	lcAlias, ;
	lcField
with This
	lnPos = at('.', .ControlSource)
	if lnPos > 0 and not .Value == evaluate(.ControlSource)
		lcAlias = left(.ControlSource, lnPos - 1)
		lcField = substr(.ControlSource, lnPos + 1)
		if used(lcAlias)
			replace (lcField) with .Value in (lcAlias)
		else
			store .Value to (.ControlSource)
		endif used(lcAlias)
	endif lnPos > 0 ...
endwith

ENDPROC
PROCEDURE validation
* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*anychange Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
*hideballoontip Hides a balloon tip for the control
*lsaveanchor_assign 
*onformchange Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
*release Releases the object
*shortcutmenu Populates the shortcut menu
*showballoontip Shows a balloon tip for the control
*showmenu Display a shortcut menu
*updatecontrolsource Updates the ControlSource with the new value
*validation An abstract method for custom validation code
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
cballoontiptitle The title for the balloon tip
lballoontips .T. to use balloon tips
lbindtoformanychange .T. to bind this control's AnyChange event to its form's AnyChange method
lhaveballoontipcontrol .T. if the form has a balloon tip control
lnotifyonformchange .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
lsaveanchor This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
lskipvalidonformclose .T. if we can skip validating this control when the form is closed
luseformshortcutmenu .T. if the form's shortcut menu items should be included with this object's
nsavedanchor The anchor value saved in lSaveAnchor_Assign
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for all TextBox objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sftextbox
[START PROPERTIES]
Tahoma, 0, 9, 5, 14, 12, 25, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RCX18PHHP
[CLASS] timer
[BASECLASS] timer
[OBJNAME] sftimer
[START PROPERTIES]
</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
<memberdata name="cleanup" type="method" display="Cleanup"/>
<memberdata name="lrelease" type="property" display="lRelease"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
Height = 23
Name = "sftimer"
Width = 23
_memberdata =      632<VFPData>
builder = 
lrelease = .F.
oexception = .NULL.
ohook = .NULL.
[END PROPERTIES]
[START PROTECTED]
calledfromthisclass
cleanup
lrelease
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Cleanup as the object is destroyed.

This.Cleanup()

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Handles errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number of the command in error 
* Returns:			may return an error resolution string (see SFERRORS.H for
*						a list) or may RETURN, RETRY, or CANCEL
* Environment in:	if a global error handler object exists, it's in the global
*						variable oError
*					a global ON ERROR routine may be in effect
* Environment out:	depends on the error resolution chosen
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	loParent, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError  = .oException.ErrorNo
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* If we're sitting on a form and that form has a FindErrorHandler method, call
* it to travel up the containership hierarchy until we find a parent that has
* code in its Error method. Also, if it has a SetError method, call it now so
* we don't lose the message information (which gets messed up by TYPE()).

if type('Thisform') = 'O'
	loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
		Thisform.FindErrorHandler(This), .NULL.)
	if pemstatus(Thisform, 'SetError', 5)
		Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
	endif pemstatus(Thisform, 'SetError', 5)
else
	loParent = .NULL.
endif type('Thisform') = 'O'
do case

* We have a parent that can handle the error.

	case not isnull(loParent)
		lcReturn = loParent.Error(lnError, lcMethod, lnLine)

* We have an error handling object, so call its ErrorHandler() method.

	case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
		if pemstatus(oError, 'SetError', 5)
			oError.SetError(lcMethod, lnLine, lcSource, @laError)
		endif pemstatus(oError, 'SetError', 5)
		lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

	case not empty(on('ERROR'))
		lcError = upper(on('ERROR'))
		lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
		lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
		lcError = strtran(lcError, ',ERROR()',  ',lnError')
		lcError = strtran(lcError, ' ERROR()',  ' lnError')
		lcError = strtran(lcError, 'LINENO()',  'lnLine')
		lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
		lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

		if left(lcError, 3) = 'DO ' or '=' $ lcError
			&lcError
			lcReturn = ccMSG_CONTINUE
		else
			lcReturn = &lcError
		endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

	otherwise
		lcSource  = message(1)
		lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
			ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
			iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
			ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
			transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
		if version(2) = 0
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose OK to continue or Cancel to cancel execution', ;
				MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
		else
			lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
				'Choose Yes to display the debugger, No to continue ' + ;
				'without the debugger, or Cancel to cancel execution', ;
				MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
		endif version(2) = 0
		do case
			case lnChoice = IDYES
				lcReturn = ccMSG_DEBUG
			case lnChoice = IDCANCEL
				lcReturn = ccMSG_CANCEL
		endcase
endcase

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
	ccMSG_CONTINUE, lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = ccMSG_RETRY
		retry

* Cancel execution.

	case lcReturn = ccMSG_CANCEL
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFTimer
* Based On:						Timer
* Purpose:						The base class for all Timer objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:				12/15/2005
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	Height:						23 so the object is small when dropped on a form
*	Width:						23 so the object is small when dropped on a form
*
* Changes in "Based On" class methods:
*	Destroy:					cleanup as the object is destroyed
*	Error:						calls the parent Error method so error handling
*								goes up the containership hierarchy
*
* Custom public properties added:
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	oException:					a reference to an Exception object
*	oHook:						a reference to a hooked object
*
* Custom protected properties added:
*	lRelease:					.T. as the object is being released
*
* Custom public methods added:
*	About:						provides documentation for the class
*	Release:					releases the object
*	ReleaseMembers:				abstract method to nuke member references
*
* Custom protected methods added:
*	CalledFromThisClass:		returns .T. if a method was called from this
*								class
*	Cleanup:					cleans up member references when the object is
*								released or destroyed
*==============================================================================

ENDPROC
PROCEDURE calledfromthisclass
*==============================================================================
* Method:			CalledFromThisClass
* Status:			Protected
* Purpose:			Determines if the method that called this method was called
*						from a method of this class or an ancestor
* Author:			Doug Hennig
* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
* Last Revision:	09/27/2001
* Parameters:		none
* Returns:			.T. if the method that called this method was called from a
*						method of this class or an ancestor
* Environment in:	none
* Environment out:	none
* Notes:			The reason we want to know if the method that called this
*						method was called from a method of this class or not is
*						to permit "read-only" properties to be changed only by
*						methods of this class. This would typically be called
*						from an Assign method, such as:
*
*					lparameters tuNewValue
*					if This.CalledFromThisClass()
*						This.<property> = tuNewValue
*					else
*						error 1743, '<property>'   && property is read-only
*					endif This.CalledFromThisClass()
*==============================================================================

local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	loParent, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn, ;
	lcThisName

* Get the name of the program that called us, and get the object name from it.
* Set loParent to our parent if there is one.

lnLevel   = program(-1)
lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI

* If we didn't come from ourselves or an ancestor and we have a parent, our
* name may not match our class, so check the containership hierarchy.

if not llReturn and not isnull(loParent)
	lcThisName = This.Name
	do while vartype(loParent) = 'O'
		lcThisName = loParent.Name + '.' + lcThisName
		loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
			.NULL.)
	enddo while vartype(loParent) = 'O'
	llReturn = upper(lcObject) == upper(lcThisName)
endif not llReturn ...
return llReturn

ENDPROC
PROCEDURE cleanup
*==============================================================================
* Method:			Cleanup
* Status:			Protected
* Purpose:			Nuke member objects
* Author:			Doug Hennig
* Copyright:		(c) 1998 Stonefield Systems Group Inc.
* Last Revision:	03/24/99
* Parameters:		none
* Returns:			.T. if everything succeeded
* Environment in:	This.lRelease is .T. if we're already in the process of
*						releasing
* Environment out:	This.lRelease is .T.
*					This.oHook is .NULL.
*					This.ReleaseMembers() was called
* Notes:			This methods avoids use of "with This" to prevent potential
*						problems with dangling object references
*==============================================================================

if This.lRelease
	return .F.
endif This.lRelease
This.lRelease = .T.
This.ReleaseMembers()
This.oHook = .NULL.

ENDPROC
PROCEDURE release
* Release the object. Note the avoidance of "with This" in this code to prevent
* potential problems with dangling object references.

if This.lRelease
	nodefault
	return .F.
endif This.lRelease
This.Cleanup()
release This

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*calledfromthisclass Returns .T. if a method was called from this class
*cleanup Cleans up member references when the object is released or destroyed
*release Releases the object
*releasemembers Abstract method to nuke member references
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class specified as Library,Class)
lrelease .T. as the object is being released
oexception A reference to an Exception object
ohook A reference to a hooked object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for all Timer objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sftimer

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RD90MLE4F
[CLASS] toolbar
[BASECLASS] toolbar
[OBJNAME] sftoolbar
[START PROPERTIES]
</VFPData>
<memberdata name="about" type="method" display="About"/>
<memberdata name="aerrorinfo" type="property" display="aErrorInfo"/>
<memberdata name="afterrefresh" type="method" display="AfterRefresh" favorites="True"/>
<memberdata name="beforerefresh" type="method" display="BeforeRefresh" favorites="True"/>
<memberdata name="builder" type="property" display="Builder"/>
<memberdata name="cleanup" type="method" display="Cleanup"/>
<memberdata name="finderrorhandler" type="method" display="FindErrorHandler"/>
<memberdata name="handleerror" type="method" display="HandleError"/>
<memberdata name="lerrorinfosaved" type="property" display="lErrorInfoSaved"/>
<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
<memberdata name="lrelease" type="property" display="lRelease"/>
<memberdata name="nlasterror" type="property" display="nLastError"/>
<memberdata name="oerror" type="property" display="oError"/>
<memberdata name="oexception" type="property" display="oException"/>
<memberdata name="ohook" type="property" display="oHook"/>
<memberdata name="omenu" type="property" display="oMenu"/>
<memberdata name="refreshform" type="method" display="RefreshForm"/>
<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
<memberdata name="reseterror" type="method" display="ResetError"/>
<memberdata name="seterror" type="method" display="SetError"/>
<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
<memberdata name="showmenu" type="method" display="ShowMenu"/>
Caption = "Toolbar1"
Name = "sftoolbar"
_memberdata =     1576<VFPData>
builder = 
lerrorinfosaved = .F.
lerroroccurred = .F.
lrelease = .F.
nlasterror = 0
oerror = .NULL.
oexception = .NULL.
ohook = .NULL.
omenu = .NULL
[END PROPERTIES]
[START PROTECTED]
cleanup
lerrorinfosaved
lrelease
[END PROTECTED]
[START METHODS]
PROCEDURE DblClick
* Don't undock the toolbar on a double-click.

nodefault

ENDPROC
PROCEDURE Destroy
*==============================================================================
* Method:			Destroy
* Status:			Public
* Purpose:			Called when the object is being destroyed
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	03/04/2000
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the toolbar and any member objects are destroyed
*==============================================================================

with This

* Hide the toolbar so it appears to go away faster.

	.Hide()

* Cleanup as the object is destroyed.

	.Cleanup()
endwith

ENDPROC
PROCEDURE Error
*==============================================================================
* Method:			Error
* Status:			Public
* Purpose:			Called when an error occurs in this object or a member
*						object
* Author:			Doug Hennig
* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
* Last revision:	02/16/2003
* Parameters:		tnError  - the error number
*					tcMethod - the method that caused the error
*					tnLine   - the line number where the error occurred
* Returns:			varies
* Environment in:	an error has occurred
*					This.oException may contain an Exception object
* Environment out:	control may be returned to the object/method that caused
*						the error (either as RETURN or RETRY) or to the routine
*						containing the READ EVENTS for the application
*					the form may be released
*					see This.SetError() and This.HandleError() for other
*						environmental changes
*==============================================================================

lparameters tnError, ;
	tcMethod, ;
	tnLine
local lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcReturn, ;
	lcReturnToOnCancel, ;
	lnPos, ;
	lcObject
with This

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

	lcMethod = tcMethod
	lnLine   = tnLine
	lcSource = message(1)
	aerror(laError)
	if vartype(.oException) = 'O'
		lcMethod = .oException.Procedure
		lnLine   = .oException.LineNo
		lcSource = .oException.LineContents
		laError[cnAERR_NUMBER]  = .oException.ErrorNo
		laError[cnAERR_MESSAGE] = .oException.Message
		laError[cnAERR_OBJECT]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'

* Use SetError() and HandleError() to gather error information and handle it.

	.SetError(lcMethod, lnLine, lcSource, @laError)
	.lErrorInfoSaved = .F.
	lcReturn = .HandleError()

* Figure out where to go if the user chooses "Cancel".

	do case
		case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
			upper(.Name)
			lcReturnToOnCancel = ''
		case type('.oError.cReturnToOnCancel') = 'C'
			lcReturnToOnCancel = .oError.cReturnToOnCancel
		case type('oError.cReturnToOnCancel') = 'C'
			lcReturnToOnCancel = oError.cReturnToOnCancel
		otherwise
			lcReturnToOnCancel = 'MASTER'
	endcase
endwith

* Handle the return value, depending on whether the error was "ours" or came
* from a member.

lnPos    = at('.', lcMethod)
lcObject = iif(lnPos = 0, '', upper(left(lcMethod, lnPos - 1)))
do case

* We're supposed to close the form, so do so and return to the master program
* (we'll just cancel if we *are* the master program).

	case lcReturn = ccMSG_CLOSEFORM
		This.Release()
		if empty(lcReturnToOnCancel)
			cancel
		else
			return to &lcReturnToOnCancel
		endif empty(lcReturnToOnCancel)

* This wasn't our error, so return the error resolution string.

	case lnPos > 0 and not (lcObject == upper(This.Name) or ;
		'DATAENVIRONMENT' $ upper(lcMethod))
		return lcReturn

* Display the debugger.

	case lcReturn = ccMSG_DEBUG
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry.

	case lcReturn = ccMSG_RETRY
		retry

* If Cancel was chosen but the master program is this form, we'll just cancel.

	case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
		cancel

* Cancel was chosen, so return to the master program.

	case lcReturn = ccMSG_CANCEL
		return to &lcReturnToOnCancel

* Return to the routine in error to continue on.

	otherwise
		return
endcase

ENDPROC
PROCEDURE Release
* Release the object. Note the avoidance of "with This" in this code to prevent
* potential problems with dangling object references.

if This.lRelease
	nodefault
	return .F.
endif This.lRelease
This.Cleanup()

ENDPROC
PROCEDURE RightClick
* Display a right-click menu.

This.ShowMenu()

ENDPROC
PROCEDURE about
*==============================================================================
* Class:						SFToolbar
* Based On:						Toolbar
* Purpose:						The base class for all Toolbar objects
* Author:						Doug Hennig
* Copyright:					(c) 1996-2006 Stonefield Systems Group Inc.
* Last revision:				04/26/2006
* Include file:					SFCtrls.H
*
* Changes in "Based On" class properties:
*	None
*
* Changes in "Based On" class methods:
*	DblClick:					don't undock the toolbar on a double-click
*	Destroy:					hides the toolbar so it disappears faster, and
*								clean up other things
*	Error:						calls This.SetError and This.HandleError
*	Release:					calls This.Cleanup
*	RightClick:					calls This.ShowMenu
*
* Custom public properties added:
*	aErrorInfo:					an array of error information
*	Builder:					tells BUILDER.APP the name of a specific
*								builder to use for this class (specified as
*								Library,Class)
*	lErrorOccurred:				.T. if an error occurred (set in Error)
*	nLastError:					the index to the last error that occurred in
*								aErrorInfo
*	oException:					a reference to an Exception object
*	oError:						a reference to an error handling object
*	oHook:						a reference to a hooked object
*	oMenu:						a reference to an SFShortcutMenu object
*
* Custom protected properties added:
*	lErrorInfoSaved:			.T. if the error information has been saved in
*								aErrorInfo
*	lRelease:					.T. as the object is being released
*
* Custom public methods added:
*	About:						provides documentation for the class
*	AfterRefresh:				an abstract method of code to execute after a
*								form is refreshed
*	BeforeRefresh:				an abstract method of code to execute before a
*								form is refreshed
*	FindErrorHandler:			called by the Error method of contained objects
*								to find a parent that has code in its Error
*								method
*	HandleError:				calls the ErrorHandler method of the oError
*								object (if there is a valid one) or displays a
*								generic error message
*	RefreshForm:				refreshes the form
*	ReleaseMembers:				abstract method to nuke member references
*	ResetError:					resets lErrorOccurred and aErrorInfo
*	SetError:					sets lErrorOccurred and aErrorInfo to
*								information  about the most recent error
*	ShortcutMenu:				populates the shortcut menu
*	ShowMenu:					display a shortcut menu
*
* Custom protected methods added:
*	Cleanup:					cleans up member references when the object is
*								released or destroyed
*==============================================================================

ENDPROC
PROCEDURE cleanup
*==============================================================================
* Method:			Cleanup
* Status:			Protected
* Purpose:			Nuke member objects
* Author:			Doug Hennig
* Copyright:		(c) 1998 Stonefield Systems Group Inc.
* Last Revision:	03/04/2000
* Parameters:		none
* Returns:			.T. if everything succeeded
* Environment in:	This.lRelease is .T. if we're already in the process of
*						releasing
* Environment out:	This.lRelease is .T.
*					This.oHook, oError, and oMenu are .NULL.
*					This.ReleaseMembers() was called
* Notes:			This methods avoids use of "with This" to prevent potential
*						problems with dangling object references
*==============================================================================

if This.lRelease
	return .F.
endif This.lRelease
This.lRelease = .T.
This.ReleaseMembers()
This.oHook    = .NULL.
This.oError   = .NULL.
This.oMenu    = .NULL.

ENDPROC
PROCEDURE finderrorhandler
*==============================================================================
* Method:			FindErrorHandler
* Status:			Public
* Purpose:			Travel up the containership hierarchy until we find a
*						parent for the specified object that has code in its
*						Error method
* Author:			Doug Hennig
* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
* Last revision:	04/02/2002
* Parameters:		toObject - an object reference to the desired object
* Returns:			an object reference to the first parent of the specified
*						object that has code in its Error method if one could
*						be found, or .NULL. if not
* Environment in:	none
* Environment out:	none
* Note:				Tthis method prevents a problem with controls sitting on
*						base class Page or Column objects -- no error trapping
*						gets done if no custom code is directly entered into
*						these objects
*
*					This mechanism only works in the VFP development
*						environment or in an APP/EXE with debug info turned on
*==============================================================================

lparameters toObject
local loParent
loParent = toObject.Parent
do while vartype(loParent) = 'O'
	do case
		case pemstatus(loParent, 'Error', 0)
			exit
		case type('loParent.Parent') = 'O'
			loParent = loParent.Parent
		otherwise
			loParent = .NULL.
	endcase
enddo while vartype('loParent') = 'O'

* If we couldn't find a valid parent object (likely because we're running in an
* EXE with debug info turned off, let's return ourselves.

if isnull(loParent)
	loParent = This
endif isnull(loParent)
return loParent

ENDPROC
PROCEDURE handleerror
*==============================================================================
* Method:			HandleError
* Status:			Public
* Purpose:			Handles an error
* Author:			Doug Hennig
* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
* Last revision:	12/15/2005
* Parameters:		none
* Returns:			a string indicating the error resolution; see SFERRORS.H
*						for the possible values
* Environment in:	This.nErrorInfo points to the row in This.aErrorInfo that
*						has information about the current error
* Environment out:	an error message may have been displayed, or some other
*						error resolution may have been taken
* Notes:			if This.oError contains an error handling object, its
*						ErrorHandler method is called
*					if a global oError contains an error handling object, its
*						ErrorHandler method is called
*					if an ON ERROR routine is in effect, it's called
*					if none of these is true, a generic error message is
*						displayed
*==============================================================================

local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcErrorMessage, ;
	lcErrorInfo, ;
	lcSource, ;
	loError, ;
	lcReturn, ;
	lcError, ;
	lcMessage, ;
	lnChoice
with This
	lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
	lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
	lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
	lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
	lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
	lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]

* Get a reference to our error handling object if there is one. It could either
* be a member of the form or a global object.

	do case
		case vartype(.oError) = 'O'
			loError = .oError
		case type('oError.Name') = 'C'
			loError = oError
		otherwise
			loError = .NULL.
	endcase
	do case

* If the error is "cannot set focus during valid" or "DataEnvironment already
* unloaded", we'll let it go.

		case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
			lcReturn = ccMSG_CONTINUE

* We have an error handling object, so call its ErrorHandler() method.

		case not isnull(loError)
			lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

		case not empty(on('ERROR'))
			lcError = upper(on('ERROR'))
			lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
			lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
			lcError = strtran(lcError, ',ERROR()',  ',lnError')
			lcError = strtran(lcError, ' ERROR()',  ' lnError')
			lcError = strtran(lcError, 'LINENO()',  'lnLine')
			lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
			lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

			if left(lcError, 3) = 'DO ' or '=' $ lcError
				&lcError
				lcReturn = ccMSG_CONTINUE
			else
				lcReturn = &lcError
			endif left(lcError, 3) = 'DO ' ...

* We don't have an error handling object, so display a dialog box.

		otherwise
			lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
				ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
				iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
				ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
				transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
			if version(2) = 0
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose OK to continue or Cancel to cancel execution', ;
					MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
			else
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
			endif version(2) = 0
			lcReturn = ccMSG_CONTINUE
			do case
				case lnChoice = IDYES
					lcReturn = ccMSG_DEBUG
				case lnChoice = IDCANCEL
					lcReturn = ccMSG_CANCEL
			endcase
	endcase
endwith
lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
	ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
return lcReturn

ENDPROC
PROCEDURE refreshform
*==============================================================================
* Method:			RefreshForm
* Status:			Public
* Purpose:			Refreshes the form
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	11/04/98
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	the form has been refreshed and any code in the
*						BeforeRefresh and AfterRefresh methods has executed
*==============================================================================

with This
	.LockScreen = .T.
	.BeforeRefresh()
	.Refresh()
	.AfterRefresh()
	.LockScreen = .F.
endwith

ENDPROC
PROCEDURE reseterror
*==============================================================================
* Method:			ResetError
* Status:			Public
* Purpose:			Reset lErrorOccurred and aErrorInfo
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	03/16/98
* Parameters:		none
* Returns:			.T.
* Environment in:	none
* Environment out:	This.lErrorOccurred is .F.
*					This.nLastError is 1
*					This.aErrorInfo is dimensioned to a single blank row
*==============================================================================

with This
	.lErrorOccurred = .F.
	dimension .aErrorInfo[1, cnAERR_MAX]
	.aErrorInfo = ''
	.nLastError = 1
endwith

ENDPROC
PROCEDURE seterror
*==============================================================================
* Method:			SetError
* Status:			Public
* Purpose:			Handle errors
* Author:			Doug Hennig
* Copyright:		(c) 1996-2006 Stonefield Systems Group Inc.
* Last revision:	04/26/2006
* Parameters:		tcMethod - the method or function the error occurred in
*					tnLine   - the line number within tcMethod
*					tcSource - the code causing the error
*					taError  - an array of error information
* Returns:			.T.
* Environment in:	This.aErrorInfo is dimensioned appropriately
*					This.lErrorSet is .T. if this method has already been called
*						for this error
* Environment out:	This.lErrorOccurred is .T.
*					This.lErrorSet is .T.
*					This.nLastError points to the current row in This.aErrorInfo
*					This.aErrorInfo is filled with error information as
*						follows:
*
*					Column	Information
*					------	-----------
*					1 - 7	same as AERROR()
*					8		method error occurred in
*					9		line error occurred on
*					10		code causing error
*					11		date/time error occurred
*					12		not used
*					13		XML string of properties and their values for the
*							object that caused the error (may be blank)
*==============================================================================

lparameters tcMethod, ;
	tnLine, ;
	tcSource, ;
	taError
local lnRows, ;
	lnCols, ;
	lnLast, ;
	lnError, ;
	lnRow, ;
	lnI
external array taError
with This

* If we've already been called, just update the method information.

	if .lErrorInfoSaved
		.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
	else

* Flag that an error occurred.

		.lErrorOccurred  = .T.
		.lErrorInfoSaved = .T.
		lnRows = alen(taError, 1)
		lnCols = alen(taError, 2)
		lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
		dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]

* For each row in the error array, put each column into our array.

		for lnError = 1 to lnRows
			lnRow = lnLast + lnError
			for lnI = 1 to lnCols
				.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
			next lnI

* Add some additional information to the current row in our array.

			.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
			.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
			.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
				iif(tcSource = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
				tcSource)
			.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
		next lnError
		.nLastError = alen(.aErrorInfo, 1)
	endif not .lErrorInfoSaved
endwith

ENDPROC
PROCEDURE shortcutmenu
*==============================================================================
* Method:			ShortcutMenu
* Status:			Public
* Purpose:			Populates the specified menu object
* Author:			Doug Hennig
* Copyright:		(c) 1996 Stonefield Systems Group Inc.
* Last revision:	12/11/98
* Parameters:		toMenu   - an object reference to a menu object
*					tcObject - the name of the variable containing the object
*						reference to this object
* Returns:			.T.
* Environment in:	none
* Environment out:	additional items were added to the menu
*==============================================================================

lparameters toMenu, ;
	tcObject

ENDPROC
PROCEDURE showmenu
*==============================================================================
* Method:			ShowMenu
* Status:			Public
* Purpose:			Displays a shortcut menu
* Author:			Doug Hennig
* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
* Last revision:	07/20/2004
* Parameters:		none
* Returns:			.T.
* Environment in:	SFMenu.VCX can be found
* Environment out:	a menu may have been displayed
*==============================================================================

local lcLibrary
private loObject, ;
	loHook
with This

* Define reference to objects we might have menu items from in case the action
* for a bar is to call a method of an object, which can't be done using "This.
* Method" since "This" isn't applicable in a menu.

	loObject = This
	loHook   = .oHook

* Define the menu if it hasn't already been defined.

	lcLibrary = 'SFMenu.vcx'
	if vartype(.oMenu) <> 'O' and file(lcLibrary)
		.oMenu = newobject('SFShortcutMenu', lcLibrary)
	endif vartype(.oMenu) <> 'O' ...
	if vartype(.oMenu) = 'O'

* If there aren't any bars in the menu, have the ShortcutMenu method populate
* it.

		if .oMenu.nBarCount = 0
			.ShortcutMenu(.oMenu, 'loObject')

* Use the hook object (if there is one) to do any further population of the
* menu.

			if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
				loHook.ShortcutMenu(.oMenu, 'loHook')
			endif vartype(loHook) = 'O' ...
		endif .oMenu.nBarCount = 0

* Activate the menu if necessary.

		if .oMenu.nBarCount > 0
			.oMenu.ShowMenu()
		endif .oMenu.nBarCount > 0
	endif vartype(.oMenu) = 'O' ...
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*about Provides documentation for the class
*afterrefresh An abstract method of code to execute after a form is refreshed
*beforerefresh An abstract method of code to execute before a form is refreshed
*cleanup Cleans up member references when the object is released or destroyed
*finderrorhandler Find the first parent for a specified object that has code in its Error method
*handleerror Calls the ErrorHandler method of the oError object (if there is a valid one) or displays a generic error message
*refreshform Refreshes the form
*releasemembers Abstract method to nuke member references
*reseterror Resets lErrorOccurred and aErrorInfo
*seterror Sets lErrorOccurred and aErrorInfo to information about the most recent error
*shortcutmenu Populates the shortcut menu
*showmenu Display a shortcut menu
^aerrorinfo[1,0] An array of error information
_memberdata XML Metadata for customizable properties
builder Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
lerrorinfosaved .T. if the error information has been saved in aErrorInfo
lerroroccurred .T. if an error occurred (set in Error)
lrelease .T. as the object is being released
nlasterror The index to the last error that occurred in aErrorInfo
oerror A reference to an error handling object
oexception A reference to an Exception object
ohook A reference to a hooked object
omenu A reference to an SFShortcutMenu object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
The base class for all Toolbar objects[END RESERVED7]
[START RESERVED8]
sfctrls.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sftoolbar
[EOF]
